import time
import random
import logging
import requests
import signal

from functools import wraps
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry


# requests_retry_session taken from:
# https://www.peterbe.com/plog/best-practice-with-retries-with-requests
def requests_retry_session(
        retries=3,
        backoff_factor=0.3,
        status_forcelist=(500, 502, 504),
        session=None):
    session = session or requests.Session()
    retry = Retry(
            total=retries,
            read=retries,
            connect=retries,
            backoff_factor=backoff_factor,
            status_forcelist=status_forcelist,
        )
    adapter = HTTPAdapter(max_retries=retry)
    session.mount('http://', adapter)
    session.mount('https://', adapter)

    return session

# Also, a custom retry utiity for things other than HTTP requests
def do_with_retry(
        func,
        backoff_type = 'constant',
        max_total_wait_time_sec = None,
        max_attempts = None,
        base_sleep_time_sec = 30,
        max_sleep_time_sec = 300,
        fuzzy = True,
        pass_exceptions = None):
    allowed_backoff_types = [ 'constant', 'exponential' ]
    assert backoff_type in allowed_backoff_types, \
            'Invalid backoff parameter: {} (allowed: {})'.format(
                    backoff_type, allowed_backoff_types)

    assert max_total_wait_time_sec or max_attempts, \
            'Please specify at least one of: max_total_wait_time_sec, max_attempts'

    def do(remaining_attempts):
        try:
            result = func()
            return (result, True)
        except Exception as e:
            if remaining_attempts > 1 and any(
                    isinstance(e, pe) for pe in ( pass_exceptions or [] ) ):
                return (None, False)

            raise e

    def get_sleep_time(num_wait_cycles):
        mean_sleep_time_sec = base_sleep_time_sec if backoff_type == 'constant' else \
                base_sleep_time_sec * (2 ** num_wait_cycles)

        mean_sleep_time_sec = min(max_sleep_time_sec, mean_sleep_time_sec)

        return mean_sleep_time_sec if not fuzzy else random.expovariate(1.0 / mean_sleep_time_sec)

    max_total_wait_time_sec = max_total_wait_time_sec or 1e8
    remaining_wait_time_sec = max_total_wait_time_sec

    max_attempts = max_attempts or (1 << 64)
    remaining_attempts = max_attempts

    (item, succeeded) = do(remaining_attempts)
    remaining_attempts -= 1

    while not succeeded:
        if remaining_attempts <= 0:
            break

        if remaining_wait_time_sec <= 0:
            break

        sleep_time_sec = get_sleep_time(max_attempts - remaining_attempts - 1)
        time.sleep(sleep_time_sec)
        remaining_wait_time_sec -= sleep_time_sec

        (item, succeeded) = do(remaining_attempts)
        remaining_attempts -= 1

    return (item, max_total_wait_time_sec - remaining_wait_time_sec, max_attempts - remaining_attempts)


def retryable(ExceptionToCheck, tries=4, delay=3, backoff=2, logger=None):
    """Retry calling the decorated function using an exponential backoff.

    http://www.saltycrane.com/blog/2009/11/trying-out-retry-decorator-python/
    original from: http://wiki.python.org/moin/PythonDecoratorLibrary#Retry

    :param ExceptionToCheck: the exception to check. may be a tuple of
        exceptions to check
    :type ExceptionToCheck: Exception or tuple
    :param tries: number of times to try (not retry) before giving up
    :type tries: int
    :param delay: initial delay between retries in seconds
    :type delay: int
    :param backoff: backoff multiplier e.g. value of 2 will double the delay
        each retry
    :type backoff: int
    :param logger: logger to use. If None, print
    :type logger: logging.Logger instance
    """
    def deco_retry(f):

        @wraps(f)
        def f_retry(*args, **kwargs):
            mtries, mdelay = tries, delay
            while mtries > 1:
                try:
                    return f(*args, **kwargs)
                except ExceptionToCheck as e:
                    msg = "%s, Retrying in %d seconds..." % (str(e), mdelay)
                    if logger:
                        logger.warning(msg)
                    else:
                        print(msg)
                    time.sleep(mdelay)
                    mtries -= 1
                    mdelay *= backoff
            return f(*args, **kwargs)

        return f_retry  # true decorator

    return deco_retry


class TimeoutError(Exception):

    def __init__(self, value = "Timed Out"):
        self.value = value

    def __str__(self):
        return repr(self.value)


def timeout(seconds_before_timeout):
    """
    Copied from:
    https://www.saltycrane.com/blog/2010/04/using-python-timeout-decorator-uploading-s3/
    """

    def decorate(f):

        def handler(signum, frame):
            raise TimeoutError()

        def new_f(*args, **kwargs):
            old = signal.signal(signal.SIGALRM, handler)
            signal.alarm(seconds_before_timeout)
            try:
                result = f(*args, **kwargs)
            finally:
                # reinstall the old signal handler
                signal.signal(signal.SIGALRM, old)
                # cancel the alarm
                signal.alarm(0)
            return result
        new_f.__name__ = f.__name__
        return new_f
    return decorate
