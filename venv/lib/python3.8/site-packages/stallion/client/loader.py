from builtins import str
from builtins import object
import time
import logging
import six
from stallion import util
from stallion.config import ConfigManager
from stallion.components import ComponentManager
from stallion.client import runtimes
from stallion.client.runtimes.static import StaticRuntime


class CachingConfigLoader(object):
    """ Utility class for loading runtime configs from within services.
        This class can be used as-is, or customized by extending it and
        changing some of the class properties, below.
    """

    # subtree is a dot-delimited path within the total service config that
    # we want this loader to extract.  This is useful if your code only
    # wants / needs a portion of the overall config pushed for the service.
    # for example, if subtree is set to "auth.authorized_groups" then the
    # `item` attached to this class will be the list of authorized groups
    # defined in the auth config.  The remaining sections of the config
    # will not be visible to your code via this class.
    DEFAULT_SUBTREE = None


    # Allow derived subclasses to specify fields to ignore when deserializing
    # configs from RuntimeConfigurator.  This is especially useful for
    # disabling KMS decryption of unneeded secrets, which is slow and also
    # has a restrictive API rate limit, so we have to be careful.  Note that
    # ignore_fields filters are applied before subtree filters, so the two
    # are compatible.
    DEFAULT_IGNORE_FIELDS = None


    # validate_config_schema sets whether the loader validates the schema
    # of the *entire* service config upon load.  It may be useful to disable
    # this if your code only depends on part of the schema and you don't
    # want to break if other, independent parts change their schemas without
    # updating the code in your service.  Example: the auth service runs
    # alongside every other service.  We ideally would not have to release
    # a new auth base image in response to schema changes in other services,
    # so the auth service sets validate_config_schema = False
    validate_config_schema = True

    # Extra config validator allows you to provide an additional validation
    # method to call on the config after it's pulled from the config service.
    # This is especially useful to set here, rather than doing downstream
    # validation, because the CachingConfigLoader will do an automatic
    # fallback to an earlier valid config version if there are failures in
    # the validators (this fallback would not be possible if
    # CachingConfigLoader did not know about the failures).
    # Note: extra_config_validator must _return_ the validated config; this
    # provides the possibility, for example, of filling-in extra or default
    # values.
    @classmethod
    def extra_config_validator(cls, descriptor, config):
        return config

    # How often to refresh the local configs by checking against the
    # runtime config service
    refresh_time_sec = 600

    # We provide a mechanism for derived quantities to be compute at
    # config-load-time, so that they will be updated automatically every
    # time the config is reloaded.
    derived_object_builders = {}

    @property
    def item(self):
        self._reload_if_stale(safe=True)

        return self._item

    def __getitem__(self, key):
        return self.item[key]

    def get(self, key, default=None):
        return self.item.get(key, default)

    def get_derived(self, name):
        if name not in self._derived:
            raise KeyError(name)

        self._reload_if_stale(safe=True)

        return self._derived.get(name)

    def _reload_if_stale(self, safe):
        def _doit():
            if self._is_stale():
                self._reload(safe)

        if not self.lock:
            _doit()
        else:
            with self.lock:
                _doit()

    def _is_stale(self):
        """ Check whether the cached config and derived variables
            are due to be refreshed.

            NOTE: This method must be called by a method that holds
                  the lock, if a lock is being used.
        """
        if not self.expires_at:
            return False

        return self.expires_at < time.time()


    def __init__(self, threadsafe=False, ignore_fields=None, subtree=None, runtime=None):
        self.runtime = runtime or runtimes.select_from_environment()
        self._config_backend = None
        self._component_manager = None
        self._config_manager = None

        self.threadsafe = threadsafe
        self.lock = None
        if threadsafe:
            try:
                import gevent.lock
            except Exception as e:
                raise Exception('Gevent is not installed!  Cannot use threadsafe=True')

            self.lock = gevent.lock.BoundedSemaphore()

        self.ignore_fields = ignore_fields or self.DEFAULT_IGNORE_FIELDS
        self.subtree = subtree or self.DEFAULT_SUBTREE

        if self.subtree and self.ignore_fields and \
                self.subtree.split('.')[0] in self.ignore_fields:
            raise Exception(
                    'Configuration will yield no configs: subtree == {}, '
                    'ignore_fields == {}'.format(self.subtree, self.ignore_fields))

        self._item = None
        self._derived = {}
        self._reload(safe=False)

    def _get_subtree(self, conf):
        return conf if not self.subtree else \
            util.dict_subtree(conf, self.subtree.split('.'))

    @property
    def config_backend(self):
        if not self._config_backend:
            self._config_backend = self._get_config_backend()
        return self._config_backend

    def _get_config_backend(self):
        from stallion import client
        return client.config_backend_from_environment(
            self.runtime.project_id)

    @property
    def component_manager(self):
        if not self._component_manager:
            self._component_manager = self._get_component_manager()
        return self._component_manager

    def _get_component_manager(self):
        return ComponentManager()

    @property
    def config_manager(self):
        if not self._config_manager:
            self._config_manager = self._get_config_manager()
        return self._config_manager

    @property
    def config_manager(self):
        if not self._config_manager:
            self._config_manager = self._get_config_manager()
        return self._config_manager
      
    def _get_config_manager(self):
        return ConfigManager(
                project_id=self.runtime.project_id,
                default_config_backend=self.config_backend,
                component_manager=self.component_manager)

    def _get_config(self):
        # retrieve the component config from the config manager.  Set
        # decrypt_secrets to the same value as validate_secrets, because
        # presumably we will require access to any secrets for our service,
        # but secrets are only accessible when validate_config_schema is true
        has_code_version = self.runtime.component_version and self.runtime.component_version != 'none'
        component = self.config_manager.get_component(
                    self.runtime.component_name,
                    util.decode_version(self.runtime.component_version) if has_code_version else None,
                    validate_config = self.validate_config_schema,
                    decrypt_secrets = self.validate_config_schema,
                    ignore_fields = self.ignore_fields)

        return (component.descriptor, component.config)

    def _update_expiry_time(self):
        # save the expiry time.  If self.refresh_time_sec is None, then the
        # config never expires.
        if self.refresh_time_sec is None:
            self.expires_at = None
        else:
            logging.debug('Scheduling next refresh in %d seconds', self.refresh_time_sec)
            self.expires_at = time.time() + self.refresh_time_sec

    def _reload(self, safe = True):
        """ Reload the config and rebuild the derived values

            :param safe: if set to True, the reload and rebuild steps are
                         wrapped in a try/catch and if any failures occur,
                         the method restores the old versions of these
                         values

            NOTE: This method must be called by a method that holds
                  the lock, if a lock is being used.
        """
        def _do_reload():
            (descriptor, config) = self._get_config()

            new_item = self._get_subtree(config)

            logging.debug('Validating new config with extra_config_validator()')
            new_validated = self.extra_config_validator(descriptor, new_item)

            if self._item != new_validated:
                self._item = new_validated
                self._derived = {
                        name: builder(new_validated)
                        for (name, builder) in six.iteritems(self.derived_object_builders)
                    }

            self._update_expiry_time()

        def _do_safe_reload():
            old_item = self._item
            old_derived = self._derived

            try:
                _do_reload()
            except Exception as e:
                logging.warn(
                        'Error while reloading configuration %s:%s: %s.',
                        self.runtime.component_name,
                        self.runtime.component_version,
                        str(e))

                self._item = old_item
                self._derived = old_derived

                # Update the expiry time by another refresh interval so that
                # we don't
                self._update_expiry_time()

        if safe:
            _do_safe_reload()
        else:
            _do_reload()


class StaticConfigLoader(CachingConfigLoader):
    """ This is a convenience class provided to assist downstream users
        who may optionally load their configs statically, e.g. from a config
        file installed in the container.  It provides API compatibility
        with the CachingConfigLoader, including all the derived object builders
        etc., but it takes its config in the constructor and that config
        never gets updated.
    """
    refresh_time_sec = None

    def __init__(self, static_config):
        self._static_config = static_config

        runtime = StaticRuntime()

        super(StaticConfigLoader, self).__init__(threadsafe=False, runtime=runtime)


    def _get_config(self):
        return (None, self._static_config)
