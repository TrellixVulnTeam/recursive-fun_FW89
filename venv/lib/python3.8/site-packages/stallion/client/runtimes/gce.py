import os
import requests
from stallion import exceptions
from stallion.client.runtime import ClientRuntime
from typing import Optional
from http import HTTPStatus

class ComputeEngine(ClientRuntime):
    name = "gce"
    def __init__(
            self,
            project_id,
            component_name,
            service_port,
            component_version=None,
            server_name=None):
        self._project_id = project_id
        self._service_port = service_port
        self._component_name = component_name

        # SERVER_NAME and SERVICE_VERSION are not required.  The server name
        # can be filled-in with a default; if SERVICE_VERSION is not provided,
        # then we leave it as None.
        self._server_name = server_name or self.default_server_name()
        self._component_version = component_version

        self._secure = self._check_tls()

    @classmethod
    def load_from_environment(cls):
        project_id = cls.get_from_metadata('project/project-id')
        component_name = os.getenv('SERVICE_NAME')
        service_port_str = os.getenv('SERVICE_PORT')

        if not all([project_id, component_name, service_port_str]):
            raise exceptions.InvalidRuntime(
                'Not a valid Compute Engine runtime.  Expected environment '
                'variables:\n  '
                'GOOGLE_CLOUD_PROJECT (found: {})\n  '
                'SERVICE_NAME (found: {})\n  '
                'SERVICE_PORT (found: {})'.format(
                    project_id,
                    component_name,
                    service_port_str))

        try:
            service_port = int(service_port_str)
        except ValueError:
            raise Exception(
                'Invalid value {} for SERVICE_PORT environment variable: '
                'must be an integer!'.format(
                    service_port_str))

        project_id_from_env = os.getenv('GOOGLE_CLOUD_PROJECT') or \
                os.getenv('GCLOUD_PROJECT')
        if project_id_from_env and project_id_from_env != project_id:
            raise exceptions.InvalidRuntime(
                'Conflicting project id found in the environment: {} ('
                'does not match the value from the metadata server ({}))'.format(
                    project_id_from_env,
                    project_id))

        return cls(
                project_id=project_id,
                component_name=component_name,
                service_port=service_port,
                component_version=os.getenv('SERVICE_VERSION'),
                server_name=os.getenv('SERVER_NAME'))

    @property
    def secure(self):
        return self._secure

    @property
    def project_id(self):
        return self._project_id

    @property
    def component_name(self):
        return self._component_name

    @property
    def component_version(self):
        return self._component_version

    @property
    def service_port(self):
        return self._service_port

    @property
    def server_name(self):
        return self._server_name

    def log_handler(self, log_name):
        try:
            from google.cloud.logging.handlers.handlers import CloudLoggingHandler
            from google.cloud.logging.resource import Resource
            from google.cloud.logging import Client
        except ImportError:
            return super(ComputeEngine, self).log_handler(log_name)

        instance_id = self.get_from_metadata('instance/id')
        zone = self.get_from_metadata('instance/zone')

        if not instance_id or not zone:
            return super(ComputeEngine, self).log_handler(log_name)

        resource = Resource(
            type='gce_instance',
            labels={
                'project_id': self.project_id,
                'instance_id': instance_id,
                'zone': zone.split('/')[-1],
            }
        )

        client = Client(_use_grpc=False)
        return CloudLoggingHandler(
            client,
            name=log_name,
            resource=resource)

    def default_server_name(self):
        return '{self.component_name}-dot-{self.project_id}-dot-us-central1.etsycloud.com'.format(
                self=self)

    @staticmethod
    def get_from_metadata(subpath) -> Optional[str]:
        PROJECT_ID_URI = 'http://metadata/computeMetadata/v1/{subpath}'.format(
                subpath=subpath)
        PROJECT_ID_HEADERS = { 'Metadata-Flavor': 'Google' }

        try:
            response: requests.Response = requests.get(PROJECT_ID_URI, headers=PROJECT_ID_HEADERS)
        except requests.ConnectionError:
            return None

        # If the metadata endpoint is a 404 we're almost certainly not on GCE.
        if response.status_code == HTTPStatus.NOT_FOUND:
            return None
        elif response.status_code != HTTPStatus.OK:
            raise Exception(
                'Unknown status code {} from GCE metadata request: {}'.format(
                    response.status_code, response.content))

        return response.text

    def _check_tls(self):
        if os.getenv('TLS_FROM_STALLION'):
            return True

        crt_path = os.getenv('TLS_CRT_PATH')
        key_path = os.getenv('TLS_KEY_PATH')

        if not crt_path and not key_path and self.service_port != 443:
            return False

        if not crt_path and not key_path:
            raise exceptions.InvalidRuntime(
                'Not a valid Google Compute Engine configuration: '
                'Missing TLS configuration for service on port 443! '
                'Please either set env vars TLS_CRT_PATH and TLS_KEY_PATH, '
                'or install the certificates in Stallion-secrets and set '
                'the env var TLS_FROM_STALLION=true')

        if not crt_path or not key_path:
            raise exceptions.InvalidRuntime(
                'Invalid TLS configuration: both of {TLS_CRT_PATH, TLS_KEY_PATH} '
                'expected, found: TLS_CRT_PATH=={}, TLS_KEY_PATH=={}'.format(
                    crt_path,
                    key_path))

        if not os.path.isfile(crt_path):
            raise exceptions.InvalidRuntime('TLS_CRT_PATH `{}` is not a file!'.format(crt_path))

        if not os.path.isfile(key_path):
            raise exceptions.InvalidRuntime('TLS_KEY_PATH `{}` is not a file!'.format(key_path))

        return True
