import os
import json
import jinja2
from stallion import util, constants


def _get_cloudsql_config(context):
    if 'service' not in context or 'cloudsql' not in context['service']:
        raise Exception(
                'cloudsql config not present in context {}'.format(context))

    return context['service']['cloudsql']


def _find_database(cloudsql_config, db_name):
    databases = {
                db['name']: idx
                for (idx, db) in enumerate(cloudsql_config['databases'])
            }

    if not db_name and len(databases) > 1:
        raise Exception(
                'Ambiguous database name specification: Instance {} contains databases {} but no database name was specified'.format(
                    cloudsql_config['instance_name'],
                    list(databases.keys())))

    db_index = 0 if not db_name else databases.get(db_name)

    if db_index is None:
        raise Exception('Database name `{}` not found in CloudSQL config for instance {} (which contains databases {}).  Could not build deployment configuration.'.format(
            db_name,
            cloudsql_config['instance_name'],
            list(databases.keys())))

    return cloudsql_config['databases'][db_index]


def _cloudsql_instance(project_id, instance_name):
    unix_socket_template = '{project_id}:us-central1:{instance_name}'

    return unix_socket_template.format(
            project_id = project_id,
            instance_name = instance_name)


def _cloudsql_unix_socket(project_id, instance_name):
    instance = _cloudsql_instance(project_id, instance_name)
    return os.path.join('/cloudsql', instance)


@jinja2.contextfunction
def get_cloudsql_db(context, db_name = None):
    cloudsql_config = _get_cloudsql_config(context)
    return _find_database(cloudsql_config, db_name)


@jinja2.contextfunction
def get_cloudsql_db_name(context, db_name = None):
    cloudsql_config = _get_cloudsql_config(context)
    return _find_database(cloudsql_config, db_name)['name']


@jinja2.contextfunction
def get_cloudsql_db_user(context, db_name = None):
    cloudsql_config = _get_cloudsql_config(context)
    return _find_database(cloudsql_config, db_name)['user']


@jinja2.contextfunction
def get_cloudsql_db_password(context, db_name = None):
    cloudsql_config = _get_cloudsql_config(context)
    return _find_database(cloudsql_config, db_name)['password']


@jinja2.contextfunction
def build_cloudsql_db_instance(context):
    cloudsql_config = _get_cloudsql_config(context)
    return _cloudsql_instance(
            project_id = context['project_id'],
            instance_name = cloudsql_config['instance_name'])


@jinja2.contextfunction
def get_image_url(context):
    return context['component'].build_image_url()


@jinja2.contextfunction
def get_domain_name(context):
    if 'server_name' in context:
        return context['server_name']

    return "{service_name}-dot-{project_id}-dot-us-central1.etsycloud.com".format(
                service_name=context['service']['name'],
                project_id=context['project_id'])


@jinja2.contextfunction
def build_cloudsql_unix_socket(context):
    cloudsql_config = _get_cloudsql_config(context)
    return _cloudsql_unix_socket(
            project_id = context['project_id'],
            instance_name = cloudsql_config['instance_name'])

@jinja2.contextfunction
def build_cloudsql_conn_str(context, db_name = None):
    cloudsql_config = _get_cloudsql_config(context)
    db = _find_database(cloudsql_config, db_name)

    conn_str_template = \
        'mysql+mysqldb://{username}:{password}@localhost/{db_name}?charset=utf8&unix_socket={unix_socket}'

    unix_socket = _cloudsql_unix_socket(
            project_id = context['project_id'],
            instance_name = cloudsql_config['instance_name'])

    return conn_str_template.format(
            username = db['user'],
            password = db['password'],
            db_name = db['name'],
            unix_socket = unix_socket)


@jinja2.contextfunction
def build_cloudsql_tcp_conn_str(context, db_name: str = None) -> str:
    """
    A TCP connection (using 127.0.0.1 instead of localhost) is sometimes needed to communicate across containers
    running on the same GCE instance.  The socket approach works on App Engine though.

    This currently uses a hardcoded port of 3306 (the mysql default). If a port option were added to the CloudSQLSchema
    in the future it would respect that.

    :param context: the jinja context, passed automatically
    :param db_name: the database instance
    :return: the mysql flavored connection string
    """
    cloudsql_config = _get_cloudsql_config(context)
    db = _find_database(cloudsql_config, db_name)

    conn_str_template = \
        'mysql+mysqldb://{username}:{password}@127.0.0.1:{db_port}/{db_name}?charset=utf8'

    return conn_str_template.format(
            username=db['user'],
            password=db['password'],
            db_name=db['name'],
            db_port=db.get('port', '3306'))


@jinja2.contextfunction
def insert_file_content(
        context: dict,
        filename: str,
        as_yaml_string: bool = False,
        lstrip: bool = False,
        rstrip: bool = False,
        render_file_content: bool = False) -> str:
    """ A context function for inserting the content of a file into the template.
        If the template is a yaml file, we support the insertion of multi-line
        strings via the as_yaml_string parameter.

        :param context: the jinja context, passed automatically
        :param filename: path to the file read
        :param as_yaml_string: whether to format the file content as a string
            that can be inserted into a yaml file.  If true, the file content
            will be rendered as a string that can be safely inserted on a
            single line directly into a yaml file, including surrounding
            quotation marks (and so therefore it is safe for inclusion in a
            json file, too)
        :param lstrip: whether to run .lstrip() to clear leading whitespace
            from the file content
        :param rstrip: whether to run .rstrip() to clear trailing whitespace
            from the file content
        :param render_file_content: whether to apply rendering to the results
            of the file insertion
    """

    base_path = context.get('base_file_path')

    file_path = os.path.join(base_path, filename.lstrip('/')) if base_path else filename

    with open(file_path) as _in:
        base_string = _in.read()

    if lstrip:
        base_string = base_string.lstrip()

    if rstrip:
        base_string = base_string.rstrip()

    if render_file_content:
        env = _jinja_env(base_path)

        template = env.from_string(base_string)

        base_string = template.render(
            project=context['project'],
            project_id=context['project_id'],
            service=context['service'],
            component=context['component'],
            **context['component'].descriptor.get('deploy_vars', {}))

    # if as_yaml_string is true, then use json.dumps to handle any necessary
    # string encoding, including enclosing the string in quotation marks.
    # yaml.dump() adds extra formatting that I worry will create
    # invalid yaml files in some cases
    return base_string if not as_yaml_string else json.dumps(base_string)


@jinja2.contextfunction
def is_vpc_network_dataproc(network):
    """
    Determines if a dataproc cluster, given its network identifier, is on the VPC or not
    """
    return 'etsy-sharedvpc' in network


@jinja2.contextfunction
def config_backend_json(context, as_yaml_string=True):
    """ Return a JSON containing the component's `config_backend` setting,
        for inclusion in deployment config files.  Throws an exception if the
        component does not have a `config_backend`, because if you're calling
        this method then presumably one is required (because it will be loaded
        by a deployed client service).
    """
    component = context.get('component')
    project = context.get('project')

    config_backend = component.descriptor.get('config_backend') or project.config_backend

    if not config_backend:
        raise Exception(
            'config_backend not defined for component `{}` with descriptor {}'.format(
                component.name,
                component.descriptor))

    dumped = json.dumps(config_backend)

    # if as_yaml_string is true, then we use json.dumps() again to properly
    # encode characters for placement inside a yaml file.
    return dumped if not as_yaml_string else json.dumps(dumped)


def _jinja_env(base_file_path):
    """ Initialize the jinja environment """
    env = jinja2.Environment()

    env.globals['get_domain_name'] = get_domain_name
    env.globals['get_image_url'] = get_image_url

    env.globals['cloudsql_db_name'] = get_cloudsql_db_name
    env.globals['cloudsql_db_user'] = get_cloudsql_db_user
    env.globals['cloudsql_db_password'] = get_cloudsql_db_password
    env.globals['cloudsql_db'] = get_cloudsql_db

    env.globals['cloudsql_instance'] = build_cloudsql_db_instance
    env.globals['cloudsql_conn_str'] = build_cloudsql_conn_str
    env.globals['cloudsql_tcp_conn_str'] = build_cloudsql_tcp_conn_str
    env.globals['cloudsql_unix_socket'] = build_cloudsql_unix_socket

    env.globals['insert_file'] = insert_file_content
    env.globals['base_file_path'] = base_file_path

    env.globals['is_vpc_network_dataproc'] = is_vpc_network_dataproc

    env.globals['config_backend_json'] = config_backend_json
    env.globals['config_backend_env_var'] = constants.CONFIG_BACKEND_ENV_VAR

    env.filters['encode_version'] = util.encode_version

    return env


def render_deploy_template(
        project,
        component,
        template_content,
        base_file_path=None):

    env = _jinja_env(base_file_path=base_file_path)

    template = env.from_string(template_content)

    return template.render(
            project=project,
            project_id=project.id,
            service=component.descriptor,
            component=component,
            **component.descriptor.get('deploy_vars', {}))


def render_deploy_file(project, component, input_path):
    template_content = None
    with open(input_path) as _in:
        template_content = _in.read()

    base_path = os.path.dirname(input_path)

    return render_deploy_template(project, component, template_content, base_path)


def render_config_file(input_path):
    template_content = None
    with open(input_path) as _in:
        template_content = _in.read()

    env = _jinja_env(base_file_path=os.path.dirname(input_path))
    template = env.from_string(template_content)

    return template.render()
