from builtins import str
from builtins import object
import abc
import os
import logging
import tempfile
import shutil
import collections
import re
import six
from stallion import exceptions
from future.utils import with_metaclass

# Define a named tuple for the outcome of the comparison between deployed and
# expected versions
CheckResult = collections.namedtuple('CheckResult', ['same', 'different', 'unknown'])

class BaseDeployHook(with_metaclass(abc.ABCMeta, object)):

    @abc.abstractmethod
    def run(component, deployer, workdir, dry_run):
        pass

class BaseDeployer(with_metaclass(abc.ABCMeta, object)):

    # each deployer can define a list of files or directories that are required
    # for deployment, and that, when altered, mandate re-deployment of the service
    deploy_files = [ ]

    priority = 0

    @abc.abstractproperty
    def type():
        pass

    @classmethod
    def extra_validation(cls, component):
        """ If you override this, you must do so with a _classmethod_"""
        pass

    @classmethod
    def validate_component(cls, component):
        for filename in cls.deploy_files:
            path = os.path.join(component.config_dir, filename)
            if not os.path.isfile(path):
                raise Exception(
                        'Invalid {} deployment for component {}: required file {} not found at path {}!'.format(
                            component.descriptor['deployment_type'],
                            component.name,
                            filename,
                            path))

        cls.extra_validation(component)

    @abc.abstractmethod
    def _do_deploy(self, component, existing_versions, workdir, dry_run):
        pass

    @abc.abstractmethod
    def get_components_to_deploy(
            self,
            expected_components,
            conf_manager,
            force_deploy_all=False,
            force_deploy_components=None):
        pass

    @classmethod
    def prettify_output(cls, cmd):
        return re.sub('\s+', ' ', cmd)


    def get_deployment_uri(self, component):
        raise NotImplemented('get_deployment_uri() not implemented for class ' +
                str(self.__class__) + ' and component ' + component.name +
                '. Perhaps this deployment type does not produce URIs?')

    def deploy_component(self, component, existing_versions, dry_run):
        if component.descriptor.get('deployment_type') != self.type:
            raise Exception('Invalid deployer type {} for component {} (Expected {})'.format(
                self.type,
                component.name,
                component.descriptor.get('deployment_type')))

        tempdir = tempfile.mkdtemp()
        logging.debug("Using temporary working directory %s", tempdir)
        try:
            for hook in component.before_deploy_hooks:
                hook.run(component, self, tempdir, dry_run)

            self._do_deploy(component, existing_versions, tempdir, dry_run)

            for hook in component.after_deploy_hooks:
                hook.run(component, self, tempdir, dry_run)
        finally:
            logging.debug("Removing temporary directory %s", tempdir)
            shutil.rmtree(tempdir)

    def __init__(self, project):
        self.project = project

    @property
    def project_id(self):
        return self.project.id

    def _render_config_template(self, component, template_path):
        # import template from within here so that we can import this module
        # without installing all of the deployment dependencies
        from stallion import template

        # ideally the existence of the template file should have been
        # guaranteed upstream, but it can't hurt to double-check
        assert os.path.isfile(template_path), \
                'file not found at path {}'.format(template_path)

        rendered_config = template.render_deploy_file(
                self.project,
                component,
                template_path)

        logging.debug('Rendered %s to: \n%s', template_path, rendered_config)
        return rendered_config


class ServiceVersion(with_metaclass(abc.ABCMeta, object)):
    """ Define a container to use as a return type for get_deployed_versions()
        methods.  This will be useful for allowing the deployer to store
        deployment-specific information that can be passed back to it as needed
    """
    def __init__(self, service_name, version):
        self.service_name = service_name
        self.version = version



    @abc.abstractproperty
    def is_active(self):
        pass


class BaseVersionedArtifactDeployer(BaseDeployer):
    @abc.abstractmethod
    def get_deployed_versions(self, relevant_components):
        """ Return value should be a list of ServiceVersion objects
            for services/versions that the deployer has records for.
        """
        pass


    def delete_stale_versions(
            self,
            components,
            max_age_seconds,
            clean_unknown_components,
            dry_run):
        logging.info('No stale-version logic for deployer %s', self.type)


    def get_components_to_deploy(
            self,
            expected_components,
            conf_manager,
            force_deploy_all=False,
            force_deploy_components=None):
        """ Determine which components to deploy, based on the components expected
            and those that are currently deployed.

            :param expected_components: the components we expect to be deployed
            :type expected_components: list<Component>
            :param conf_manager: A ConfigManager
            :type conf_manager: ConfigManager
            :param force_deploy_all: whether to force re-deployment of all components,
                irrespective of whether deployment is determined to be necessary
            :type force_deploy_all: bool
            :param force_deploy_components: A list of component names for which to
                force re-deployment, irrespective of whether deployment is
                determined to be necessary
            :type force_deploy_components: list<string>

            :returns A list of components needing re-deploy, paired with any
                information about the currently-deployed artifacts corresponding
                to those components
            :rtype: list <Component, list<ServiceVersion>>
        """

        deployed_versions = self._group_versions(self.get_deployed_versions(expected_components))
        comparison = self.check_deployed_services(
                deployed_versions=deployed_versions,
                expected_versions={
                        component.name: component.code_version
                        for component in expected_components
                    })

        # initialize the result with the components that are different from
        # those currently deployed, because we know that these will definitely
        # require re-deployment
        result = [ (component, deployed_versions.get(component.name, []))
            for component in expected_components
            if component.name in comparison.different ]

        for (component, existing_deploys) in result:
            logging.info('For deployer `%s`: component %s requires re-deploy '
                         'due to version mismatch.  Existing deployment versions: %s',
                         self.type,
                         component,
                         [ v.version for v in existing_deploys if v.is_active ])

        force_deploy_components = frozenset(force_deploy_components or [])
        for component in expected_components:
            if component.name not in comparison.same:
                continue

            if force_deploy_all:
                logging.info(
                        'For deployer `%s`: component %s marked for re-deploy because force_deploy_all was set',
                        self.type,
                        component.name)
                result.append((component, deployed_versions.get(component.name, [])))
                continue

            if component.name in force_deploy_components:
                logging.info(
                        'For deployer `%s`: component %s marked for re-deploy because force_deploy_components was set',
                        self.type,
                        component.name)
                result.append((component, deployed_versions.get(component.name, [])))
                continue

            if component.needs_redeploy(deployer=self, conf_manager=conf_manager):
                logging.info(
                        'For deployer `%s`: component %s requires re-deploy due to fingerprint change',
                        self.type,
                        component.name)
                result.append((component, deployed_versions.get(component.name, [])))
                continue

            logging.info(
                    'For deployer `%s`: component %s is up-to-date',
                    self.type,
                    component.name)

        for deployment_name in comparison.unknown:
            logging.warn(
                    'For deployer `%s`: unknown deployment %s was found',
                    self.type,
                    deployment_name)

        return result


    @staticmethod
    def _group_versions(versions):
        result = {}
        for version in versions:
            result.setdefault(version.service_name, [])
            result[version.service_name].append(version)

        return result


    @staticmethod
    def _filter_active_versions(versions):
        """ Filter the dictionary of all deployed versions down to only those
            that are active.

            :param versions: the deployed versions, generated by calling
                _group_version(get_deployed_versions(relevant_components))
            :type versions: dict(version_name -> list<ServiceVersion>)

            :returns: a dictionary of versions, filtered to include only active
                versions
            :rtype: dict(version_name -> list<ServiceVersion>)
        """
        result = {}
        for (name, items) in six.iteritems(versions):
            filtered_items = [ item for item in items if item.is_active ]
            if filtered_items:
                result[name] = filtered_items

        return result


    def check_deployed_services(self, deployed_versions, expected_versions):
        same = {}
        diff = {}
        unknown = {}

        active_versions = self._filter_active_versions(deployed_versions)

        all_service_names = frozenset(active_versions) | frozenset(expected_versions)

        for name in all_service_names:
            if name not in active_versions:
                diff[name] = [ expected_versions[name] ]
                continue

            for item in active_versions[name]:
                if item is None:
                    logging.warn("Found a 'None' version deployed for [" + name + "]")

            if name not in expected_versions:
                unknown[name] = active_versions[name]
                continue

            target_version = expected_versions[name]

            if len(active_versions[name]) > 1 or active_versions[name][0].version != target_version:
                diff[name] = active_versions[name]
                continue

            same[name] = [ target_version ]

        return CheckResult(same = same, different = diff, unknown = unknown)
