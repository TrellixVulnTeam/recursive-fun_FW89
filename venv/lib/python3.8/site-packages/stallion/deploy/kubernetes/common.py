import logging
import abc
import subprocess
import re
import json
from stallion.deploy.base import ServiceVersion, BaseVersionedArtifactDeployer


class KubernetesServiceVersion(ServiceVersion):
    COMPONENT_NAME_LABEL = 'stallion-component-name'
    CODE_VERSION_LABEL = 'stallion-code-version'

    # no notion of an inactive service
    is_active = True

    """ A class for parsing deployment information retrieved from `kubectl get deployments`
        and retrieving stallion-specific information.
    """
    def __init__(self, deployment):
        self.deployment = deployment

        super(KubernetesServiceVersion, self).__init__(
            service_name=self.component_name,
            version=self.code_version)

    @property
    def labels(self):
        return self.deployment.get('metadata', {}).get('labels', {})

    @property
    def component_name(self):
        return self.labels.get(self.COMPONENT_NAME_LABEL)

    @property
    def code_version(self):
        return self.labels.get(self.CODE_VERSION_LABEL)

    @property
    def deployment_name(self):
        return self.deployment.get('metadata', {}).get('name')

    @classmethod
    def build_labels(cls, component):
        return {
            cls.COMPONENT_NAME_LABEL: component.name,
            cls.CODE_VERSION_LABEL: component.code_version,
        }


class KubernetesDeployer(BaseVersionedArtifactDeployer):
    """ A deployer that provides base implementations for vanilla kubernetes deployments.
        This class by itself is not a stand-alone deployer: it requires implementations
        to provide methods that do two things:

        - Connect to clusters
        - Prepare deployment spec files

        The former allows customizability along the lines of connecting to GKE vs. on-prem vs. ...
        kubernetes clusters, while the latter provides generic support for templating
        systems that generate deployment specs, such as Helm.
    """

    @abc.abstractmethod
    def get_cluster_credentials(self, component):
        """ Must be implemented by subclasses: for the given component, retrieve
            the credentials for the cluster that this component references.
        """
        pass

    @abc.abstractmethod
    def build_cluster_name(self, component):
        """ Must be implemented by subclasses: for the given component, build the
            name of referenced kubernetes cluster as it will be known to kubectl.

            For example, in GKE, kubectl cluster names are formed with the following
            pattern:
                gke_{project_id}_{region}_{gke_cluster_name}
        """
        pass

    @abc.abstractmethod
    def _apply_deployment_with_labels(self, labels, component, workdir, dry_run):
        """ Must be implemented by subclasses.  For the provided component, and
            with the provided labels, apply the deployment and attach the labels.

            (The labels will be the stallion-specific labels used for differentiating
            stallion-managed deployments from other deployments present on the cluster).

            This base class provides useful methods such as
                _kubectl_apply() and _apply_labels()
            that can be used by the subclasses.

            Note that the treatment of labels like this feels a little awkward,
            but it was motivated by the fact that labels can be set either post-deployment
            via kubectl commands, or pre-deployment by editing the deployment
            files.  We don't want to do the former if it's not necessary, but we
            can't really do the latter without knowing the specifics of the deployment
            file generation (e.g. is it templated?  what will the filenames be???)
        """
        pass

    def get_deployed_versions(self, relevant_components):
        """ Return value should be a list of ServiceVersion objects
            for services/versions that the deployer has records for.
        """
        if not relevant_components:
            logging.warning(
                'No relevant components from which to retrieve clusters and namespaces')
            return []

        clusters_with_namespaces = {}

        available_clusters = self._get_cached_clusters()
        for component in relevant_components:
            cluster_name = self.build_cluster_name(component)

            if cluster_name not in available_clusters:
                self.get_cluster_credentials(component)
                available_clusters |= frozenset([cluster_name])

            namespace = component.descriptor['kubernetes'].get('namespace')

            clusters_with_namespaces.setdefault(cluster_name, frozenset())
            clusters_with_namespaces[cluster_name] |= frozenset([namespace])

        return [
            version
            for (cluster, namespaces) in list(clusters_with_namespaces.items())
            for namespace in namespaces
            for version in self._get_versions(cluster, namespace)
        ]

    @staticmethod
    def _get_versions(cluster, namespace):
        """ Run kubectl to retrieve version information for all stallion-specific
            deployments on the specified cluster and in the specified namespace.

            :param cluster: the kubectl cluster name
            :type cluster: string
            :param namespace: the deployment's namespace (or None, if using the global namespace)
            :type namespace: string

            :returns: the versions
            :rtype: list<KubernetesServiceVersion>
        """
        cmd = [
            'kubectl',
            'get',
            'deployments',
            '--cluster={}'.format(cluster),
            '--namespace={}'.format(namespace),
            '--output=json',
        ]

        logging.info('Retrieving deployments with command %s', ' '.join(cmd))

        result = subprocess.check_output(cmd).decode('utf-8').strip()

        all_deployments = [
            KubernetesServiceVersion(item)
            for item in json.loads(result).get('items', [])
        ]

        stallion_deployments = [
            deployment for deployment in all_deployments
            if deployment.code_version and deployment.component_name
        ]

        return stallion_deployments

    def delete_stale_versions(
            self,
            components,
            max_age_seconds,
            clean_unknown_components,
            dry_run):
        logging.info('No stale-version logic for deployer %s', self.type)
        raise NotImplementedError('not implemented')

    def _do_deploy(self, component, existing_versions, workdir, dry_run):
        """ Implementation the superclass's required abstract method.  Basically
            just makes sure we've got cluster credentials and delegates the work
            to methods implemented by subclasses.
        """
        if self.build_cluster_name(component) not in self._get_cached_clusters():
            self.get_cluster_credentials(component)

        labels = KubernetesServiceVersion.build_labels(component)
        self._apply_deployment_with_labels(labels, component, workdir, dry_run)

    def _apply_labels(self, labels, deployment_name, component, dry_run):
        """ Utility method for applying labels to a kubernetes deployment already
            running in a cluster (i.e. post-deployment).

            :param labels: the labels to apply
            :type labels: dict
            :param deployment_name: the name of the deployment
            :type deployment_name: string
            :param component: the component corresponding to the deployment
            :type component: a subclass of stallion.components.BaseComponent
            :param dry_run: whether this is a dry-run
            :type dry_run: bool
        """
        cluster_name = self.build_cluster_name(component)
        cmd = [
            'kubectl',
            'label',
            'deployment',
            deployment_name,
            '--cluster={}'.format(cluster_name),
            '--overwrite=true',
        ]

        namespace = component.descriptor['kubernetes'].get('namespace')
        if namespace:
            cmd.append('--namespace={}'.format(namespace))

        cmd += [
            '{key}={value}'.format(key=key, value=value)
            for (key, value) in list(labels.items())
        ]

        logging.info(
            'Updating labels with command %s',
            ' '.join(cmd))

        if dry_run:
            logging.info(
                '--dry_run: not applying labels.', labels)
            return

        subprocess.check_call(cmd)

    @classmethod
    def _get_cached_clusters(cls):
        """ Retrieve the clusters for which there are already local kubectl credentials """
        cmd = [ 'kubectl', 'config', 'get-clusters' ]
        logging.info(
            'Checking for cluster credentials with command %s',
            ' '.join(cmd))

        return cls._parse_cluster_list(subprocess.check_output(cmd).decode('utf-8'))

    @classmethod
    def _parse_cluster_list(cls, get_clusters_output):
        """ Parse the output of the kubectl config get-clusters command.
            Needed because get-clusters command does not have a json formatting option :(
        """
        hit = re.match('NAME\n(?P<cluster_list>(.*\n)*)', get_clusters_output)

        return frozenset() if not hit else \
            frozenset([_f for _f in hit.group('cluster_list').split('\n') if _f])

    def _kubectl_apply(self, filename, component, recursive, dry_run):
        """ Utility method for use by subclasses to execute `kubectl apply`
            on their deployment files.  Inserts the proper cluster and namespace
            based on the information contained in the provided component object.

            :param filename: the file or directory containing the deployment spec files
            :type filename: string
            :param component: the component we're deploying
            :type component: a subclass of stallion.components.BaseComponent
            :param recursive: whether to pass the --recursive command to kubectl
            :type recursive: bool
            :param dry_run: whether this is a dry-run
            :type dry_run: bool
        """
        cluster_name = self.build_cluster_name(component)
        cmd = [
            'kubectl',
            'apply',
            '--cluster={}'.format(cluster_name),
            '--filename={}'.format(filename),
        ]

        namespace = component.descriptor['kubernetes'].get('namespace')
        if namespace:
            cmd.append('--namespace={}'.format(namespace))

        if recursive:
            cmd.append('--recursive')

        logging.info('Applying change with command: %s', ' '.join(cmd))

        if dry_run:
            logging.info('--dry_run: not applying change')
            return

        subprocess.check_call(cmd)
