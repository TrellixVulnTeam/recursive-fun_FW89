from builtins import str
import logging
import six
import os
import re
import subprocess
from .common import KubernetesDeployer


_VALUES_FILENAME = 'values.yaml'


class HelmDeployerCommon(KubernetesDeployer):
    deploy_files = [ _VALUES_FILENAME ]

    """ Implements the necessary methods for KubernetesDeployer to build deployment
        spec files using helm.

        This class is still abstract: it does not contain implementation details
        needed to connect to a kubernetes cluster.  It is meant to be mixed-in
        with other classes that provide those details, but that do not provide
        details specific to building deployment specs.
    """

    def _apply_deployment_with_labels(self, labels, component, workdir, dry_run):
        """ Implementation of the base class's abstract method.  This method
            builds the deployment files, applies them, and tags the deployment
            with the necessary labels.

            :param labels: the labels to apply
            :type labels: dict
            :param component: the component corresponding to the deployment
            :type component: a subclass of stallion.components.BaseComponent
            :param workdir: the stallion-provided temp directory
            :type workdir: string
            :param dry_run: whether this is a dry-run
            :type dry_run: bool
        """

        self._initialize_helm(workdir)

        repo_dir = self._download_repo(component, workdir)

        substitutions = self._build_substitutions(component, labels)
        deploy_dir = self._render_deployment_file(
            repo_dir=repo_dir,
            substitutions=substitutions,
            component=component,
            workdir=workdir)

        self._kubectl_apply(
            filename=deploy_dir,
            component=component,
            recursive=True,
            dry_run=dry_run)

        if not component.descriptor['kubernetes']['helm'].get('labels_values_key'):
            self._apply_labels(labels, component.name, component, dry_run)

        return component.name

    @classmethod
    def _render_deployment_file(cls, repo_dir, substitutions, component, workdir):
        """ Render the deployment spec file(s) from an already-downloaded helm
            repository.  Uses the the values.yaml file, if one exists in the config
            directory for the component, as one source of variable substitutions; the
            other source is the provided substitutions parameter.

            :param repo_dir: the directory containing the downloaded helm repository
            :type repo_dir: string
            :param substitutions: the substitutions to insert into the template
            :type substitutions: dict
            :param component: the component we're deploying
            :type component: a subclass of stallion.components.BaseComponent
            :param workdir: a temporary working directory
            :type workdir: string
        """

        output_dir = os.path.join(workdir, 'rendered-charts')

        os.makedirs(output_dir)

        cmd = cls._helm_command_builder(workdir)(
            'template',
            '--name', component.name,
            '--output-dir', output_dir,
            repo_dir,
        )

        values_file = os.path.join(component.config_dir, _VALUES_FILENAME)
        if os.path.isfile(values_file):
            cmd.append('--values={}'.format(values_file))
        else:
            logging.info(
                'Values file not found at %s: rendering from the raw template.',
                values_file)

        for (key, value) in list(substitutions.items()):
            cmd += [ '--set', cls._format_substitution(key, value) ]

        logging.info('Rendering helm chart with command: %s', ' '.join(cmd))

        subprocess.check_call(cmd)

        return output_dir

    @staticmethod
    def _build_substitutions(component, labels):
        """ Build the variable substitutions appropriate to the provided component.
            If the component specifies a key to use to insert labels into the
            template, then we include them in the result.

            :param component: the component we're deploying
            :type component: a subclass of stallion.components.BaseComponent
            :param labels: the labels to apply
            :type labels: dict
        """
        result = {}

        labels_key = component.descriptor['kubernetes']['helm'].get('labels_values_key')
        if labels_key:
            result[labels_key] = labels

        image_uri_base = component.settings['image_uri_base']

        image_key = component.descriptor['kubernetes']['helm']['image_values_key']
        image_tag_key = component.descriptor['kubernetes']['helm'].get('image_tag_values_key')
        if image_tag_key:
            result[image_tag_key] = component.version
            result[image_key] = image_uri_base
        else:
            result[image_key] = '{}:{}'.format(image_uri_base, component.version)

        return result

    @staticmethod
    def _format_substitution(key, value):
        """ Formats the provided substitution so that it can be passed to helm
            as a command-line argument.  For details, see:
            https://github.com/helm/helm/blob/master/docs/using_helm.md#the-format-and-limitations-of---set

            :param key: the substitution key
            :param value: the substitution value
        """

        format_queue = [([key], value)]

        # we use a queue-based BFS to traverse any nested structures while flattening
        # along the way
        flattened_substitutions = []
        while format_queue:
            (item_key_path, item_value) = format_queue.pop()
            if isinstance(item_value, six.string_types + (float, int)):
                # escape any special characters...  of course the Helm docs do not
                # specify the full set of these :(
                special_chars = [ ',', '=' ]
                pattern = '([{}])'.format(''.join(special_chars))
                escaped_value = re.sub(pattern, r'\\\1', str(item_value))
                flattened_substitutions.append(
                    '{}={}'.format('.'.join(item_key_path), escaped_value))
                continue

            if isinstance(item_value, dict):
                format_queue += [
                    (item_key_path + [sub_key], sub_value)
                    for (sub_key, sub_value) in list(item_value.items())
                ]
                continue

            if isinstance(item_value, (list, tuple)):
                if not item_value:
                    flattened_substitutions.append(
                        '{}={{}}'.format('.'.join(item_key_path))
                    )
                    continue

                format_queue += [
                    (item_key_path[:-1] + [ '{}[{}]'.format(item_key_path[-1], idx) ], sub_value)
                    for (idx, sub_value) in enumerate(item_value)
                ]
                continue

            raise ValueError('No formatter for value: %s', item_value)

        return ','.join(flattened_substitutions)

    @classmethod
    def _download_repo(cls, component, workdir):
        """ Download the helm repo specified by the component into the temporary
            working directory.

            :param component: the component we're deploying
            :type component: a subclass of stallion.components.BaseComponent
            :param workdir: the working directory
            :type workdir: string

            :returns the directory containing the downloaded repo
            :rtype: string
        """
        untar_dir = os.path.join(workdir, 'helm-charts')

        repo_url = component.descriptor['kubernetes']['helm']['repo_url']
        chart_name = component.descriptor['kubernetes']['helm']['chart_name']

        cmd = cls._helm_command_builder(workdir)(
            'fetch',
            '--repo={}'.format(repo_url),
            '--untar',
            '--untardir={}'.format(untar_dir),
            chart_name,
        )

        logging.info('Downloading repo %s/%s to %s', repo_url, chart_name, untar_dir)
        logging.info('Executing command: %s', ' '.join(cmd))

        subprocess.check_call(cmd)

        return os.path.join(untar_dir, chart_name)

    @classmethod
    def _initialize_helm(cls, workdir):
        """ Initialize helm in the temporary working directory.  Must be run
            before any other helm commands.
        """
        cmd = cls._helm_command_builder(workdir)('init', '--client-only')

        logging.info('Initializing helm with command %s', ' '.join(cmd))

        subprocess.check_call(cmd)

    @classmethod
    def _helm_command_builder(cls, workdir):
        """ Return a builder method for generating helm commands.  The builder
            will automatically attach any globally-shared arguments, such as the
            helm home directory, which is created when we run _initialize_helm()

            :param workdir: the temporary working directory in which we initialized helm
            :type workdir: string
            :returns: an array of commands.  Append more commands and then pass to
                subprocess methods.
            :rtype: list<str>
        """
        def builder(*args):
            return [ 'helm', '--home={}'.format(cls._helm_home_dir(workdir)) ] + list(args)

        return builder

    @staticmethod
    def _helm_home_dir(workdir):
        """ Build the helm home directory for the provided temporary working directory """
        return os.path.join(workdir, 'stallion-helm-home')
