import itertools
import logging
import re
import six
import semver
import requests
import subprocess
import uritools
from stallion import exceptions, util
from stallion.retry import retryable
from typing import Dict, List

ETSY_GITHUB_HOST = "github.etsycorp.com"


def _get_tags_from_github(owner, repository, tag_prefix) -> List[str]:
    request_path = '/api/v3/repos/{owner}/{repository}/git/refs/tags{optional_tag_prefix}'.format(
        owner=owner,
        repository=repository,
        optional_tag_prefix='' if not tag_prefix else ('/' + tag_prefix))

    request_uri = uritools.uricompose(
        scheme='https',
        host=ETSY_GITHUB_HOST,
        path=request_path)

    response = requests.get(request_uri, timeout=15)

    if response.status_code == 404:
        # Catches 404 Client Error: Not Found for url.
        # This error is thrown during a service's first build because no tags exist yet.
        return []
    else:
        response.raise_for_status()

    tags = [tag['ref'][len('refs/tags/'):] for tag in response.json()]

    return tags


def _get_tags_from_local_history(tag_prefix: str) -> List[str]:
    s = subprocess.Popen(["git tag"], shell=True, stdout=subprocess.PIPE).stdout
    all_tags_bytes = s.read().splitlines()
    all_tags_strings = [t.decode("utf-8") for t in all_tags_bytes]

    if tag_prefix:
        return [t for t in all_tags_strings if t.startswith(tag_prefix)]
    else:
        return all_tags_strings


@retryable((requests.exceptions.ReadTimeout, requests.exceptions.ConnectionError,), tries=4, delay=4, backoff=2, logger=logging)
def _get_tags(use_local_history, owner, repository, tag_prefix=None, pattern=None):
    if use_local_history:
        tags = _get_tags_from_local_history(tag_prefix)
    else:
        tags = _get_tags_from_github(owner, repository, tag_prefix)

    return tags if not pattern else [tag for tag in tags if re.match(pattern, tag)]


def _sort_tags(tags, tag_prefix):
    # sort tags by semver

    return sorted(tags, key=lambda tag: semver.VersionInfo.parse(tag[len(tag_prefix):]))


def get_versions(owner, repository, tag_separator, major_version=None, tag_names=None, use_local_history=False)\
        -> Dict[str, list]:

    tag_pattern = '.*[{}].+'.format(tag_separator)
    if tag_names:
        base_tags = [
            tag
            for tag_name in tag_names
            for tag in _get_tags(use_local_history, owner, repository, tag_name, tag_pattern)
        ]
    else:
        base_tags = _get_tags(use_local_history, owner, repository, pattern=tag_pattern)

    tags = sorted([tag
                   for tag in base_tags
                   if len(tag.split(tag_separator)) == 2
                   and (major_version == None or tag.split(tag_separator)[1].split(".")[0] == major_version) # filter if major version is specified
                   and util.is_semver(tag.split(tag_separator)[1])])

    logging.debug('Found %d tags matching pattern <name>%s<semver>%s',
            len(tags),
            tag_separator,
            '' if not tag_names else 'for tag names {}'.format(tag_names))

    result = {}
    for (tag_name, group) in itertools.groupby(tags, lambda tag: tag.split(tag_separator)[0]):
        tags = list(group)
        logging.debug('Found %d tags for tag name %s', len(tags), tag_name)
        tag_prefix = tag_name + tag_separator
        result[tag_name] = [ tag[len(tag_prefix):] for tag in _sort_tags(tags, tag_prefix) ]

    return result


def get_latest_versions(owner, repository, tag_separator, major_version = None, tag_names=None,
                        use_local_history=False) -> Dict[str, str]:

    return {item: versions[-1] for (item, versions) in
            six.iteritems(get_versions(owner, repository, tag_separator, major_version, tag_names,
                                       use_local_history=use_local_history))}


def get_latest_version(owner, repository, tag_name, tag_separator, major_version=None, use_local_history=False) -> str:
    all_latest = get_latest_versions(owner, repository, tag_separator, major_version, {tag_name},
                                     use_local_history=use_local_history)

    if tag_name not in all_latest:
        raise exceptions.MissingVersionException('no versions found for item name `{}`'.format(tag_name))

    return all_latest[tag_name]
