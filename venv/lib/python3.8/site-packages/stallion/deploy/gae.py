import json
import yaml
import subprocess
import os
import logging
import datetime
import dateutil
import six

from stallion import exceptions, util
from stallion.auth import authorizer

from stallion.deploy.base import \
        BaseVersionedArtifactDeployer, \
        ServiceVersion
from stallion.retry import retryable


class GAEServiceVersion(ServiceVersion):
    def __init__(self, item):
        super(GAEServiceVersion, self).__init__(
                service_name=item['service'],
                version=util.decode_version(item['version']['id']))
        self.item = item

    @property
    def is_active(self):
        return self.item['version']['servingStatus'] == 'SERVING' and \
               self.item['traffic_split'] > 0.0


    @property
    def is_stopped(self):
        return self.item['version']['servingStatus'] == 'STOPPED'


    @property
    def age(self):
        now = datetime.datetime.utcnow().replace(tzinfo=dateutil.tz.tzutc())
        created_at = dateutil.parser.parse(self.item['version']['createTime'])

        return now - created_at


class AppEngineCommonDeployer(BaseVersionedArtifactDeployer):
    """ Implement any common logic between GAE and GAE-Flexible.
        This class remains abstract, to be filled-in with logic that is
        specific to Standard vs Flexible
    """

    deploy_files = [ 'app.yaml' ]

    def __init__(self, project):
        super(AppEngineCommonDeployer, self).__init__(project)

        self.app_exists = self.check_whether_app_exists(project.id)


    @staticmethod
    def check_whether_app_exists(project_id):
        session = authorizer.get_access_session()

        response = session.get(
                'https://appengine.googleapis.com/v1/apps/' + project_id,
                timeout=10)

        if response.status_code not in [200, 404]:
            logging.warn(
                    'Unexpected status code for appengine apps/get request: %s',
                    response.status_code)

        if response.status_code == 404:
            logging.info('GAE app not deployed in project %s', project_id)

        return response.status_code == 200


    def prepare_deploy_dir(self, component, deploy_dir):
        """ Overrideable method for defining logic that is specific to
            GAE-Standard or GAE-Flexible
        """
        logging.debug('Nothing to do in prepare_deploy_dir() for deployer %s',
                self.type)

    def gcloud_extra_args(self, component):
        """ Overrideable method for defining logic that is specific to
            GAE-Standard or GAE-Flexible
        """
        logging.debug('No extra gcloud args for for deployer %s', self.type)
        return []

    @classmethod
    def build_app_yaml_path(cls, component):
        return os.path.join(component.config_dir, 'app.yaml')

    @classmethod
    def check_version(cls, version):
        """ Determine whether the service version corresponds with this
            deployer
        """
        raise NotImplemented('Please implement check_version in derived classes!')

    def _do_deploy(self, component, existing_versions, workdir, dry_run):
        if not self.app_exists:
            raise Exception(
                    'Cannot deploy Appengine component {} into project {} '
                    'because GAE is not enabled in that project!'.format(
                        component,
                        self.project_id))

        rendered_app_yaml = self._render_config_template(
                component=component,
                template_path=self.build_app_yaml_path(component))

        self._validate_app_yaml(component, rendered_app_yaml)

        self.prepare_deploy_dir(component, workdir)

        self._delete_existing_versions_if_needed(
                component,
                existing_versions,
                dry_run)

        self._deploy_with_rendered_app_yaml(
                component = component,
                rendered_app_yaml = rendered_app_yaml,
                workdir = workdir,
                dry_run = dry_run)


    def _delete_existing_versions_if_needed(
            self,
            component,
            existing_versions,
            dry_run):
        """ Delete any existing versions of the component that must be deleted
            in order for the deployment to succeed.  Specifically, this will
            include only services that have been deployed but are currently
            in the STOPPED state, because re-deploying to these causes errors.
            Re-deploys to running services are fine.

            :param component: the component to deploy
            :type component: Component
            :param existing_versions: the versions of this component that are already
                deployed
            :type existing_versions: list<GAEServiceVersion>
            :param dry_run: whether this is a dry run (ie whether to skip any
                state modifications)
            :type dry_run: bool
        """

        must_delete = any(v.is_stopped and v.version == component.code_version
                for v in existing_versions)

        if not must_delete:
            logging.info('No existing versions for component %s require deletion', component.name)
            return

        logging.info('Deleting existing service in STOPPED state: %s', component)

        if dry_run:
            logging.info('  dry_run: not deleting')
            return

        self._delete_service_versions(component.name, [component.code_version])


    def build_gcloud_deploy_args(self, component):
        extra_args = self.gcloud_extra_args(component)
        app_version = util.encode_version(component.code_version)

        base_args = [ 'gcloud',
                    'app',
                    'deploy',
                    '--project', self.project_id,
                    '--version', app_version ]

        return base_args + extra_args

    def get_stale_versions(self, max_age_seconds):
        all_versions = self.get_deployed_versions([])

        max_age_timedelta = None if not max_age_seconds else \
                datetime.timedelta(seconds=max_age_seconds)

        stale_versions = [ item for item in all_versions if item.is_stopped and
                (not max_age_timedelta or item.age > max_age_timedelta) ]

        return self._group_versions(stale_versions)


    def delete_stale_versions(
            self,
            components,
            max_age_seconds,
            clean_unknown_components,
            dry_run):

        component_names = frozenset(c.name for c in components)
        stale_versions = self.get_stale_versions(max_age_seconds)

        if stale_versions:
            logging.info('Stale versions found for services: %s with deployer %s',
                         ', '.join(list(stale_versions.keys())),
                         self.type)
        else:
            logging.info('No stale versions found for deployer %s', self.type)

        for (service_name, versions) in six.iteritems(stale_versions):
            if service_name not in component_names and not clean_unknown_components:
                logging.info('Skipping service %s', service_name)
                continue

            logging.info('Deleting stale GAE deployments for service %s. Stale versions: %s',
                         service_name,
                         ', '.join(v.version for v in versions))
            if dry_run:
                logging.info('  dry run: not deleting stale deployments')
                continue

            self._delete_service_versions(service_name, [v.version for v in versions])


    def _delete_service_versions(self, service, versions):
        subprocess.check_call([
            'gcloud',
            'app',
            'versions',
            'delete',
            '--project', self.project_id,
            '--service', service,
            '--quiet',
            ] + [ util.encode_version(v) for v in versions ])


    def get_deployment_uri(self, component, versioned = False):
        host_prefix = '{app_name}-dot-{project_id}'.format(
                app_name = self.build_app_name(component),
                project_id = self.project_id)

        if versioned:
            encoded_version = util.encode_version(component.code_version)
            host_prefix = encoded_version + '-dot-' + host_prefix

        # I _think_ the maximum length for this is 63, but let's be a little conservative
        if len(host_prefix) > 60:
            # TODO: This is an extremely unlikely case, and may only be possible
            # if versioned==True, but we could handle it by checking the GAE API
            # to try to determine the proper hostname directly
            raise Exception(('Host prefix {} is too long (length is {})'
                    ', I think this will cause problems...').format(len(host_prefix)))

        return 'https://' + host_prefix + '.appspot.com'

    def get_deployed_versions(self, relevant_components):
        """ Retrieve the currently-deployed services and versions for this
            GAE deployer.

            :returns: a list of tuples of (service_name, decoded version, GAE API version blob)
            :rtype: list<tuple<string>>
        """
        if not self.app_exists:
            return []

        args = [ 'gcloud',
                    'app',
                    'versions',
                    'list',
                    '--project', self.project_id,
                    '--format', 'json',
                    ]
        all_gae_versions = json.loads(subprocess.check_output(args).decode('utf-8'))

        return [ GAEServiceVersion(item) for item in all_gae_versions
                 if self.check_version(item) ]


    def _validate_app_yaml(self, component, rendered_app_yaml):
        loaded = yaml.safe_load(rendered_app_yaml)

        app_name = self.build_app_name(component)
        if loaded.get('service') != app_name:
            raise exceptions.InvalidAppYamlException(
                    'Rendered app.yaml specifies service name `{}` (expected `{}`)'.format(
                        loaded.get('service'),
                        app_name))

    @retryable((subprocess.CalledProcessError,), tries=3, delay=10, backoff=2, logger=logging)
    def _deploy_with_rendered_app_yaml(
            self,
            component,
            rendered_app_yaml,
            workdir,
            dry_run):

        logging.info(
                'Deploying app %s:%s',
                component.name,
                util.encode_version(component.code_version))

        with open(os.path.join(workdir, 'app.yaml'), 'w') as _out:
            _out.write(rendered_app_yaml)

        gcloud_args = self.build_gcloud_deploy_args(component)

        if dry_run:
            logging.info('  dry run: Skipping execution of gcloud command `%s`',
                ' '.join(gcloud_args))
            return

        else:
            subprocess.check_call(gcloud_args, cwd=workdir)

    @staticmethod
    def build_app_name(component):
        # TODO: sanitize by GAE rules
        return component.name

class AppEngineStandardDeployer(AppEngineCommonDeployer):
    type = 'gae-standard'

    @classmethod
    def check_version(cls, version):
        """ Determine whether the service version corresponds with this
            deployer
        """
        return version['environment']['name'] == 'STANDARD' and \
                version['service'] != 'default'

    def prepare_deploy_dir(self, component, deploy_dir):
        tarball_bucket = component.descriptor['gae_standard']['code_bucket']
        tarball_path = component.build_tarball_path()
        tarball_name = os.path.basename(tarball_path)

        util.gcs_download(tarball_bucket, tarball_path, deploy_dir)

        logging.info("Unpacking tarball %s", tarball_name)
        # This assumes that the tarball was created by tarring and zipping a
        # directory that contains the app.  So we untar using
        # --strip-components=1 in order to discard that parent directory and
        # install the app contents in the deploy dir.
        subprocess.check_call(
                [ 'tar', 'xvfz', tarball_name, '--strip-components', '1' ],
                cwd=deploy_dir)

        logging.info("Successfully unpacked %s; deleting", tarball_name)
        os.unlink(os.path.join(deploy_dir, tarball_name))

class AppEngineBaseAppDeployer(AppEngineStandardDeployer):
    type = 'gae-base-app'

    priority = 1

    @classmethod
    def check_version(cls, version):
        """ Determine whether the service version corresponds with this
            deployer
        """
        return version['environment']['name'] == 'STANDARD' and \
                version['service'] == 'default'

    def _validate_app_yaml(self, component, rendered_app_yaml):
        loaded = yaml.safe_load(rendered_app_yaml)

        # Nothing obvious to check here other than that it does _not_ have a
        # service name defined
        if loaded.get('service'):
            raise exceptions.InvalidAppYamlException(
                    ('app.yaml for App Engine Base Application may not specify a '
                    'service name! (found `{}`)').format(
                        loaded.get('service')))

class AppEngineFlexibleDeployer(AppEngineCommonDeployer):
    # Note: this deployer is really specific to gae-flex custom runtime;
    # standard runtime deployer should be a subclass of
    # AppEngineStandardDeployer, because the deploy processes are the same
    type = 'gae-flex'

    @classmethod
    def check_version(cls, version):
        """ Determine whether the service version corresponds with this
            deployer
        """
        return version['environment']['name'] == 'FLEX'

    def gcloud_extra_args(self, component):
        image_url = component.build_image_url()
        return [ '--image-url', image_url ]
