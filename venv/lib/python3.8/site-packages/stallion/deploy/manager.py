from builtins import object
import operator
import logging
import semver
import traceback
import six

from stallion import constants
from stallion.operations import OperationTypes, OperationStatus
from stallion.deploy import git
from stallion.deploy.base import BaseVersionedArtifactDeployer

class DeployManager(object):
    def __init__(
            self,
            conf_manager,
            dry_run,
            deployers):
        self.conf_manager = conf_manager
        self.dry_run = dry_run

        self.deployers = deployers
        self.deployer_map = {
                deployer.type: deployer for deployer in deployers
                }


    def get_deployer(self, deployer_type):
        return self.deployer_map.get(deployer_type)


    def delete_stale_versions(
            self,
            max_age_seconds,
            components=None,
            only_deployers=None,
            skip_deployers=None,
            clean_unknown_components=False):

        for deployer_type in self.deployer_map:
            if only_deployers and deployer_type not in only_deployers:
                logging.info('Skipping deployer %s', deployer_type)
                continue

            if skip_deployers and deployer_type in skip_deployers:
                logging.info('Skipping deployer %s', deployer_type)
                continue

            relevant_components = [
                    c for c in (components or [])
                    if c.descriptor['deployment_type'] == deployer_type ]

            if not relevant_components:
                logging.info('Skipping deployer %s: not required by any components in the current deploy', deployer_type)
                continue

            deployer = self.get_deployer(deployer_type)

            if not isinstance(deployer, BaseVersionedArtifactDeployer):
                logging.info('Skipping deployer %s: not a versioned-artifact deployer', deployer_type)
                continue

            deployer.delete_stale_versions(
                    components=relevant_components,
                    max_age_seconds=max_age_seconds,
                    clean_unknown_components=clean_unknown_components,
                    dry_run=self.dry_run)

            deployed_versions = {}
            for version in deployer.get_deployed_versions(relevant_components):
                deployed_versions.setdefault(version.service_name, [])
                deployed_versions[version.service_name].append(version)

            for component in relevant_components:
                active_versions = [ v.version for v in deployed_versions.get(component.name) if v.is_active ]
                if not active_versions:
                    logging.info('No active versions for component %s; skipping config cleanup', component.name)
                    continue

                logging.info('Active versions for component %s: %s',
                             component.name,
                             ', '.join(active_versions))
                self.conf_manager.delete_inactive_versions(
                        component.name,
                        active_versions=active_versions,
                        dry_run=self.dry_run)

    def deploy_updates(
            self,
            components,
            force_deploy_all=False,
            force_deploy_components=None,
            config_push_only=False,
            force_config_push=False):
        """ This is the primary public-facing method for the DeployManager class.
            It takes a list of component objects and does the following:
                1. Reconcile their versions with github (specifically: look
                   up latest versions and/or confirm that pegged versions exist)
                2. Push any config updates to RuntimeConfig
                3. Deploy new instances of any components that need updating

            The push and deploy processes are robust to failures on individual
            components: failure of one component will not block others from
            being deployed.  However if any failure occurs, the DeployManager
            will raise an exception once all components are deployed.

            :param components: the list of components
            :type components: list<Component>
            :param force_deploy_all: Whether to deploy all components, even ones
                that do not otherwise require it
            :type force_deploy_all: bool
            :param force_deploy_components: Components to force-deploy, even if
                they do not require it
            :type force_deploy_components: list<string>
            :param config_push_only: Only push configs (if needed); do not
                deploy any services.  Useful for testing, for instance if you
                want to push a config before deploying a service so that you can
                run tests locally
            :type config_push_only: bool
            :param force_config_push: Ignore config fingerprints in deciding
                whether to push configs (i.e. push all configs even if a
                push is not needed)
            :type force_config_push: bool

        """
        (supported, unsupported) = self._partition_supported_components(components)
        for component in unsupported:
            logging.info('Skipping component `%s`: unsupported deployment type `%s`',
                    component.name,
                    component.descriptor['deployment_type'])

        results = {}

        expected_versions = self._get_expected_versions(supported)
        self._log_expected_component_versions(expected_versions)

        missing_versions = [component_version for component_version in expected_versions if component_version[1] is None]
        for (component, _) in missing_versions:
            results[component.name] = {
                    'operation': OperationTypes.RESOLVE_VERSION.value,
                    'status': OperationStatus.ERROR.value
                    }

        versioned_components = self._augment_component_versions(
            [component_version for component_version in expected_versions if component_version[1] is not None])

        for (deployment_type, deploy_components) in self._group_by_deployer(versioned_components):
            deployer = self.get_deployer(deployment_type)

            (to_deploy, to_push_config) = \
                    self._partition_by_deploy_action(
                            deployer,
                            deploy_components,
                            force_deploy_all=force_deploy_all,
                            force_deploy_components=force_deploy_components)

            results.update(self._do_config_push(to_push_config, deployer, force_config_push))

            results.update(self._do_component_deploys(deployer, to_deploy, config_push_only))

        return results


    @staticmethod
    def _augment_component_versions(expected_versions):
        """ Augment any components with the latest version available for them,
            if they are configured to use the latest version.

            :param expected_versions: a list of (BaseComponent, expected_version)
                   where the Component was loaded out of configuration, and
                   expected_version was determined by resolving versions
                   against Github.
            :type expected_versions: list<tuple<BaseComponent, string>>
        """

        result = []
        for (component, version) in expected_versions:
            if not component.has_code_version:
                result.append(component)
                continue

            if component.code_version == version:
                result.append(component)
                continue

            assert component.code_version == constants.LATEST, \
                    'An internal error has caused us to load a component ' \
                    'with an invalid version: {}'.format(component)

            result.append(component.with_code_version(version))

        return result


    @staticmethod
    def _log_expected_component_versions(component_versions):
        for (component, version) in component_versions:
            if version is not None:
                continue

            logging.warn('Invalid config for component %s specified for deployment %s does not exist!',
                    component,
                    component.descriptor['deployment_type'])

        for (component, version) in component_versions:
            if version is None:
                continue

            if not component.has_code_version:
                logging.info('Expected config-only component %s: %s:%s',
                        component.name,
                        component.type,
                        version,
                        )
                continue

            logging.info('Expected deploy version for service %s %s',
                    component,
                    (' (' + version  + ')') if component.code_version_is_latest else '',
                    )

    def _partition_supported_components(self, components):
        supported = []
        unsupported = []

        for component in components:
            if component.descriptor['deployment_type'] in self.deployer_map:
                supported.append(component)
            else:
                unsupported.append(component)

        return (supported, unsupported)

    def _get_expected_versions(self, components):
        """
        This method assigns a version to each component. That version can be used later to construct URIs for
        containers in GCR, locations of cloud function code, etc.

        If a released version is specified (e.g. 0.0.1) that is validated in github and, if present, used. If not
        found in github, it will not be used.

        If "latest" is specified then github is interrogated and the tag with the highest version number is extracted
        and used.

        If a prerelease version string (as defined by semver) is used, that is allowed through without github validation

        :param components: The list of components to assign versions to
        :return: A list of (component, version) tuples. version will None if none could be retrieved or validated
                """
        result = []

        available_versions = self._get_available_versions(components)
        for component in components:
            if not component.has_code_version:
                result.append( (component, constants.NO_CODE_VERSION) )
                continue

            tag_name = component.git_tag_name

            if tag_name not in available_versions:
                logging.warn('Component type %s (tag name %s) not found in %s/%s/%s!',
                        component.type,
                        tag_name,
                        git.ETSY_GITHUB_HOST,
                        component.code_repo_owner,
                        component.code_repo)
                result.append( (component, None) )
                continue

            component_versions = available_versions[tag_name]

            if component.code_version in component_versions:
                result.append( (component, component.code_version) )
                continue

            if component.code_version_is_latest:
                result.append( (component, component_versions[-1]) )
                continue

            try:
                if semver.parse_version_info(component.code_version).prerelease:
                    result.append((component, component.code_version))
                    continue
            except ValueError:
                # Just warn here to let the deploy process continue. The component won't have a version and therefore
                # won't be deployable, but other components can continue. This check must be after the check for
                # `latest` because that is a valid, non-semver identifier.
                logging.warn('Component %s has an invalid version', component)

            logging.warn('Component %s (tag name %s) not available in %s/%s/%s!',
                    component,
                    tag_name,
                    git.ETSY_GITHUB_HOST,
                    component.code_repo_owner,
                    component.code_repo)
            result.append( (component, None) )

        return result

    def _get_available_versions(self, components):
        sources = self._get_git_sources(components)

        result = {}
        for (( owner, repo, version_separator ), tag_names) in six.iteritems(sources):
            versions = git.get_versions(
                owner=owner,
                repository=repo,
                tag_separator=version_separator,
                tag_names=tag_names)

            dupes = [ key for key in versions if key in result ]
            if dupes:
                # This will only happen if there are components that specify
                # different git source settings but with the same git tag name.
                # e.g. if somehow we have airflow components that are both
                # present and yet define sources in two different repos.  This
                # should probably never happen, so raise an exception
                raise Exception('Ambiguous sources for components `{}`: found in multiple repositories!'.format(
                    dupes))

            result.update(versions)

        return result

    def _get_git_sources(self, components):
        sources = {}
        for component in components:
            if not component.has_code_version:
                continue

            key = ( component.code_repo_owner, component.code_repo, component.git_tag_version_separator )

            sources.setdefault(key, [])
            sources[key].append(component.git_tag_name)

        return sources


    def _group_by_deployer(self, components):
        grouped_components = {}
        for component in components:
            deployment_type = component.descriptor['deployment_type']
            grouped_components.setdefault(deployment_type, [])
            grouped_components[deployment_type].append(component)

        deployer_priorities = [
                (deployment_type, self.get_deployer(deployment_type).priority)
                for deployment_type in grouped_components ]

        deployer_priorities.sort(key=operator.itemgetter(1), reverse=True)

        return [ (deployer_type, grouped_components[deployer_type])
                for (deployer_type, _) in deployer_priorities ]


    def _partition_by_deploy_action(
            self,
            deployer,
            components,
            force_deploy_all,
            force_deploy_components):
        # note: force_deploy_all might suggest that we not run
        # get_components_to_deploy(), but that method is still useful for
        # checking and logging the state of the deployer, including any
        # deployed services that are not currently configured
        to_deploy = deployer.get_components_to_deploy(
                components,
                self.conf_manager,
                force_deploy_all=force_deploy_all,
                force_deploy_components=force_deploy_components)

        deploy_names = frozenset(component.name for (component, _) in to_deploy)
        to_push_config = [ component for component in components if
                component.name not in deploy_names ]

        return (to_deploy, to_push_config)

    def _do_config_push(self, components, deployer, force_config_push):
        push_results = self.conf_manager.update_components(
                components=components,
                deployer=deployer,
                dry_run=self.dry_run,
                force_config_push=force_config_push)

        return {
                component_name: {
                        'operation': OperationTypes.CONFIG_PUSH.value,
                        'status': push_status.value
                    } for (component_name, push_status) in six.iteritems(push_results)
                }


    def _do_component_deploys(self, deployer, components, config_push_only):
        """ Deploy the components that require deployment.

            :param deployer: The deployer to use
            :type deployer: BaseDeployer
            :param components: the components to deploy, along with any existing
                deployment information for them
            :type components: list<tuple<Component, list<ServiceVersion>>>
            :param config_push_only: Whether to skip deployment and only push
                configuration updates
            :type config_push_only: boolean
        """
        results = {}
        for (component, existing_versions) in components:
            try:
                self._deploy_component(deployer, component, existing_versions, config_push_only)
                results[component.name] = {
                        'operation': OperationTypes.CONFIG_PUSH.value if config_push_only else OperationTypes.DEPLOY.value,
                        'status': OperationStatus.SUCCESS.value,
                        }
            except Exception as e:
                logging.error("Component [%s] failed to deploy", component)
                logging.error("Error message [%s]", e)
                logging.error(traceback.format_exc())
                results[component.name] = {
                        'operation': OperationTypes.DEPLOY.value,
                        'status': OperationStatus.ERROR.value
                        }

        return results

    def _deploy_component(self, deployer, component, existing_versions, config_push_only):
        """ Deploy the component in 3 steps:
            1. Push the runtime config settings for the new service, so that
               they are available to the deployed service at startup, if required
            2. Deploy the service
            3. Update the config, including running any config-push hooks, and
               write out the config and deploy fingerprints

            :param deployer: the deployer to use
            :type deployer: BaseDeployer
            :param component: the component to deploy
            :type component: Component
            :param existing_versions: A list of any existing versions that have
                already been fetched for this component
            :type existing_versions: list<ServiceVersion>
            :param config_push_only: Whether to skip deployment and only push
                configuration
            :type config_push_only: bool
        """
        # First write the configs, but do not run the config-push hooks yet
        # because those could potentially depend on the proper version of the
        # service being already deployed.  So we run those hooks after the
        # deployment completes.
        deployer.validate_component(component)

        self.conf_manager.write_component_settings(component, self.dry_run)

        if config_push_only:
            logging.info('config_push_only is True: Skipping deploy of component %s',
                         component.name)
            return

        deployer.deploy_component(component, existing_versions, self.dry_run)

        # Write the deploy fingerprint now, before running the config hooks.
        # This way any failures in running the hooks will not be cause for
        # re-deploying the service in a subsequent run of the Stallion deployer
        # scripts
        self.conf_manager.write_fingerprint(
                component=component,
                deployer=deployer,
                dry_run=self.dry_run,
                fingerprint_type='deploy')

        # After a successful deployment, update the components (including
        # running the config-push hooks and writing the fingerprint)
        self.conf_manager.update_component(component, deployer, self.dry_run)
