from builtins import object
from collections import namedtuple
import logging
import six

# GCE Autoscalers exist as separate, stand-alone entities that get
# attached to GCE managed instance groups; they are not just configuration
# settings on the instance group configurations, as you might expect.
# This class manages the create/read/update/delete flows for autoscalers.
class AutoscalingManager(object):
    def __init__(self, project_id, session):
        self.project_id = project_id
        self.session = session

    def update_autoscaler(self, component, dry_run):
        # The main public entrypoint.  This method retrieves the remote
        # autoscaler configuration for the specified component, determines
        # whether any changes need to be made, and then makes those changes.
        # If the autoscaler does not exist remotely, it will be created.
        # If an autoscaler exists remotely but the component does not
        # specify that autoscaling should be enabled, then the autoscaler
        # will be deleted.
        # :param component: the component for which to update the autoscaler
        # :type component: stallion.components.BaseComponent
        # :param dry_run: whether this is a dry run (i.e. whether updates
        # should be skipped)
        # :type dry_run: bool

        deployed_autoscaler = self._get_deployed_autoscaler(component)

        autoscaling_config = self._get_autoscaling_config(component)
        if not autoscaling_config:
            if deployed_autoscaler:
                logging.info(
                    'Autoscaler found for component %s, but no autoscaler is configured.  Deleting the autoscaler.',
                    component.name)

                if dry_run:
                    logging.info('  dry_run: not deleting autoscaler')
                    return

                self._delete_autoscaler(component, deployed_autoscaler)
            else:
                logging.info(
                    'No autoscaler configuration for component %s.',
                    component)
            return

        # if we're here, then an autoscaler is expected to have been deployed

        if not deployed_autoscaler:
            logging.info(
                'Autoscaler expected but not found for component %s; creating it.',
                component.name
            )

            if dry_run:
                logging.info('  dry_run: not creating autoscaler')
            else:
                self._create_autoscaler(component)

            return

        update = self._mismatched_settings(
            self.project_id,
            component,
            deployed_autoscaler)

        if not update:
            logging.info(
                'Autoscaler configuration for %s is up-to-date.  No update needed.',
                component)
            return

        logging.info(
            'Deployed autoscaler config for component %s does not match expected.  Applying update(s):\n  %s',
            component.name,
            '\n  '.join(
                '{}: {} => {}'.format(key, mismatch.found, mismatch.expected)
                for (key, mismatch) in six.iteritems(update)
            )
        )

        if dry_run:
            logging.info('  dry_run: not updating autoscaler')
            return

        self._update_autoscaler(component)

    @staticmethod
    def _get_autoscaling_config(component):
        # Utility method for retrieving the autoscaling configuration
        # from the component
        return component.descriptor['gce'].get('autoscaling')

    @classmethod
    def _build_autoscaler_spec(cls, project_id, component):
        # Build a GCE Autoscaler object from the component's autoscaling
        # configuration, to use either for creation/update of an autoscaler,
        # or for the purpose of comparing the remote state with the expected.
        # See: https://cloud.google.com/compute/docs/reference/rest/v1/autoscalers/insert
        def build_utilization(target):
            return {'utilizationTarget': target}

        autoscaler_config = cls._get_autoscaling_config(component)
        policy = {
            'maxNumReplicas': autoscaler_config['max_num_replicas']
        }

        if autoscaler_config.get('min_num_replicas'):
            policy['minNumReplicas'] = autoscaler_config['min_num_replicas']

        if autoscaler_config.get('cooldown_period_sec'):
            policy['coolDownPeriodSec'] = autoscaler_config['cooldown_period_sec']

        if autoscaler_config.get('cpu_utilization_target'):
            policy['cpuUtilization'] = build_utilization(
                autoscaler_config['cpu_utilization_target']
            )

        if autoscaler_config.get('load_balancing_utilization_target'):
            policy['loadBalancingUtilization'] = build_utilization(
                autoscaler_config['load_balancing_utilization_target']
            )

        if autoscaler_config.get('custom_metric_utilizations'):
            policy['customMetricUtilizations'] = [
                {
                    'metric': metric['metric'],
                    'utilizationTarget': metric['utilization_target'],
                    'utilizationTargetType': metric['utilization_target_type'],
                } for metric in autoscaler_config['custom_metric_utilizations']
            ]

        return {
            'name': component.name,
            'description': 'stallion auto-generated autoscaler',
            'target': cls._build_instance_group_manager_uri(project_id, component),
            'autoscalingPolicy': policy,
        }

    @staticmethod
    def _region_or_zone_path(component):
        config = component.descriptor['gce']

        return ('regions/' + config['region']) if config.get('zones') else \
                ('zones/' + config['zone'])

    @classmethod
    def _build_autoscaler_uri(cls, project_id, component):
        # Build the GCE autoscalers URI for the given component
        return 'https://www.googleapis.com/compute/v1/projects/{project}/{region_or_zone}/autoscalers'.format(
            project=project_id,
            region_or_zone=cls._region_or_zone_path(component))

    @classmethod
    def _build_instance_group_manager_uri(cls, project_id, component):
        # Build the GCE InstanceGroupManager URI for the given component.
        return 'https://www.googleapis.com/compute/v1/projects/{project}/{region_or_zone}/instanceGroupManagers/{name}'.format(
            project=project_id,
            region_or_zone=cls._region_or_zone_path(component),
            name=component.name)

    def _get_deployed_autoscaler(self, component):
        # Find the deployed autoscaler for the provided component, if it
        # exists.
        autoscalers = self._list_deployed_autoscalers(component)

        hit = [ autoscaler for autoscaler in autoscalers if
                autoscaler['name'] == component.name ]

        if not hit:
            return None
        elif len(hit) > 1:
            raise Exception(
                'Multiple auto-scalers found for component {}: {}'.format(
                    component.name,
                    hit))
        else:
            return hit[0]

    def _list_deployed_autoscalers(self, component):
        # Retrieve a list of all autoscalers currently deployed in the
        # project.
        # TODO: we probably shouldn't make a list call for every GCE service,
        # but right now that's what we do.  Maybe we should make one call
        # and cache the result?
        # See: https://cloud.google.com/compute/docs/reference/rest/v1/autoscalers/list
        pageToken = None
        results = []

        while True:
            params = {'pageToken': pageToken} if pageToken else {}
            response = self.session.get(
                self._build_autoscaler_uri(self.project_id, component),
                params=params,
                timeout=10
            )

            logging.debug(
                'raw response from autoscalers/list API: %s',
                response.content
            )

            if response.status_code != 200:
                # note that a successful response in a project with no autoscalers
                # sends code 200, with an empty items array.  So a 404 would
                # not indicate that there are no autoscalers, but rather that
                # the API endpoint was incorrect.
                response.raise_for_status()
            else:
                body = response.json()
                results += body.get('items', [])

                pageToken = body.get('nextPageToken')
                if pageToken is None:
                    break

        return results

    def _create_autoscaler(self, component):
        # Create a new autoscaler using the insert API.
        # See: https://cloud.google.com/compute/docs/reference/rest/v1/autoscalers/insert
        spec = self._build_autoscaler_spec(self.project_id, component)

        response = self.session.post(
            self._build_autoscaler_uri(self.project_id, component),
            json=spec,
            timeout=10)

        if response.status_code != 200:
            logging.error(
                'Error creating autoscaler: %s',
                response.content)

        response.raise_for_status()

    def _update_autoscaler(self, component):
        # Update an autoscaler using the update API.
        # See: https://cloud.google.com/compute/docs/reference/rest/v1/autoscalers/update
        spec = self._build_autoscaler_spec(self.project_id, component)

        response = self.session.put(
            self._build_autoscaler_uri(self.project_id, component),
            json=spec,
            timeout=10)

        if response.status_code != 200:
            logging.error(
                'Error updating autoscaler: %s',
                response.content)

        response.raise_for_status()

    def _delete_autoscaler(self, component, autoscaler):
        # Delete an autoscaler
        # See: https://cloud.google.com/compute/docs/reference/rest/v1/autoscalers/delete
        response = self.session.delete(
                self._build_autoscaler_uri(self.project_id, component) + '/' + autoscaler['id'],
                timeout=10)

        if response.status_code != 200:
            logging.error(
                'Error deleting autoscaler: %s',
                response.content)

        response.raise_for_status()

    @classmethod
    def _mismatched_settings(cls, project_id, component, deployed_autoscaler):
        # Compare a deployed autoscaler configuration with what we expect.
        # We expect the response from the GCE API to contain more fields than the
        # spec that we sent to it, because it adds several output-only fields,
        # and it also includes any values that were set to defaults because they
        # were absent from our request. So we check for equality only among the
        # keys that are present in our generated spec.

        different_keys = {}
        MismatchedSetting = namedtuple('MismatchedKey', ['expected', 'found'])

        def _recursive_compare(base_path, expected, found):
            for key in expected:
                full_key_path = base_path + [key]
                if isinstance(found.get(key), dict):
                    _recursive_compare(
                        full_key_path,
                        expected[key],
                        found[key]
                    )
                else:
                    if expected[key] != found[key]:
                        path = '.'.join(full_key_path)
                        different_keys[path] = MismatchedSetting(
                            expected=expected[key],
                            found=found[key]
                        )

        spec = cls._build_autoscaler_spec(project_id, component)

        _recursive_compare([], spec, deployed_autoscaler)

        return different_keys
