from builtins import map
from builtins import str
from hashlib import sha1
import re
import json
import yaml
import subprocess
import os
import logging
import time
from stallion import util
from stallion.components.base import BaseComponent
from stallion.auth import Authorizer
from stallion.deploy.base import \
        BaseVersionedArtifactDeployer, \
        ServiceVersion
from .autoscaling import AutoscalingManager


class GCEServiceVersion(ServiceVersion):
    def __init__(self, instance):
        base_instance_name = instance['baseInstanceName']

        (version, timestamp) = (None, None) if 'instanceTemplate' not in instance \
            else self.version_from_template_name(
                os.path.basename(instance['instanceTemplate']),
                base_instance_name)

        super(GCEServiceVersion, self).__init__(
                service_name=base_instance_name,
                version=version if version else None)

        self.instance = instance


    is_active = True

    @staticmethod
    def version_from_template_name(template_name, base_instance_name):
        """ Determine the deployed code version from the instance template
            name.  Requires the instance template name to be of the format
            $BASE_INSTANCE_NAME-$CODE_SEMVER-$TIMESTAMP, although the SEMVER
            is assembled with '-' between fields rather than '.'.

            Returns tuples of the form ($SEMVER, $TIMESTAMP).

            :param template_name: name of the instance template
            :type template_name: string
            :param base_instance_name: base instance name, returned by GCE API
            :type base_instance_name: string
        """
        name_pattern = base_instance_name + '-(([0-9]+-){3})([a-zA-Z0-9-]+-)?([0-9]+)'
        if not template_name.startswith(base_instance_name):
            logging.debug('Instance template name %s does not start with '
                         'base instance name %s; cannot determine instance'
                         ' template version',
                         base_instance_name,
                         template_name)
            return (None, None)

        match = re.match(name_pattern, template_name)
        if not match:
            logging.debug(
                    'Unrecognized template version %s for instance '
                    'template %s: not of the format $SEMVER-$TIMESTAMP',
                    template_name[1+len(base_instance_name):],
                    template_name)
            return (None, None)

        major_minor_patch = match.group(1).rstrip('-').replace('-', '.')
        prerelease = match.group(3)
        semver = '-'.join([_f for _f in [major_minor_patch, prerelease] if _f]).rstrip('-')

        timestamp = int(match.group(4))

        logging.info(
                'Parsed template name %s to service version %s, timestamp %d',
                template_name,
                semver,
                timestamp)

        return (semver, timestamp)


class ComputeEngineDeployer(BaseVersionedArtifactDeployer):
    type = 'gce'

    deploy_files = [ 'cloud-init.yaml' ]

    # Experimental feature. That URI will have to be defined elsewhere.
    def get_deployment_uri(self, component, versioned=False):
        host_prefix = '{app_name}-dot-{project_id}'.format(
                app_name = component.name,
                project_id = self.project_id)

        if versioned:
            encoded_version = util.encode_version(component.code_version)
            host_prefix = encoded_version + '-dot-' + host_prefix

        return 'https://' + host_prefix + '-dot-us-central1.etsycloud.com'

    def get_deployed_versions(self, relevant_components):
        """ Find all deployed managed instance groups and the versions of
            their associated instance templates
        """
        gcloud_args = [
                'gcloud',
                'compute',
                'instance-groups',
                'managed',
                'list',
                '--format=json',
                '--project', self.project_id ]

        result = json.loads(subprocess.check_output(gcloud_args).decode('utf-8'))

        return self.get_GCEServiceVersions_from_groups(result)

    @staticmethod
    def get_GCEServiceVersions_from_groups(result):
        return [ item for item in map(GCEServiceVersion, result) if item.version ]

    @classmethod
    def build_cloud_init_path(cls, component):
        return os.path.join(component.config_dir, 'cloud-init.yaml')

    @classmethod
    def build_service_version_name(cls, component):
        template_version = util.encode_version(component.code_version)
        timestamp = int(time.time()*1000)
        # The full instance group name may only be up to 61 characters long
        # The timestamp and the hyphen before it are 14 characters, so the
        # service name and version can be no longer than 47 characters
        name_and_version = "{}-{}".format(component.name, template_version)
        if len(name_and_version) > 47:
            name_and_version_hash = sha1(name_and_version.encode("utf-8")).hexdigest()[:6]
            name_and_version = name_and_version[:40] + "-" + name_and_version_hash
        return "{}-{}".format(name_and_version, timestamp).lower()

    @staticmethod
    def instance_group_uri(project_id, component):
        zone_or_region_path = (
            'regions/' + component.descriptor['gce']['region']
        ) if component.descriptor['gce'].get('zones') else (
            'zones/' + component.descriptor['gce']['zone']
        )

        return 'https://www.googleapis.com/compute/v1/projects/{project}/{zone_or_region}/instanceGroupManagers/{name}'.format(
            project = project_id,
            zone_or_region = zone_or_region_path,
            name = component.name
        )

    def _get_instance_group(self, component, session):
        response = session.get(
            self.instance_group_uri(self.project_id, component),
            timeout=10)

        if response.status_code < 300:
            return response.json()
        elif response.status_code == 404:
            logging.info('Instance group %s does not exist', component.name)
            return None

        response.raise_for_status()

    @staticmethod
    def instance_template_uri(project, name):
        return 'https://www.googleapis.com/compute/v1/projects/{project}/global/instanceTemplates/{name}'.format(**locals())

    def _check_if_instance_template_exists(self, service_name, session):
        response = session.get(
            self.instance_template_uri(self.project_id, service_name),
            timeout=10)

        if response.status_code < 300:
            return True
        elif response.status_code == 404:
            return False

        response.raise_for_status()

    def _delete_instance_template(self, component, template_version, service_name):

        cmd = "echo y | gcloud compute instance-templates delete {instance_template_name} --project {project}".format(
                instance_template_name=service_name,
                project=self.project_id)

        return cmd

    def _build_network_config(self, config):
        def port_legacy_network():
            return [] if not config.get('default_network_uri') else [{
                    'network': config['default_network_uri'],
                    'subnet': config['default_subnetwork_uri'],
                    'no_address': True,
                }]

        def build_network_directive(network):
            return '--network-interface=network={network},subnet={subnet},no-address'.format(**network)

        networks = port_legacy_network() + config.get('network_interfaces', [])

        return ' '.join(map(build_network_directive, networks))

    def _create_instance_template(self, component: BaseComponent,
                                  cloud_init_path: str, template_version: str, service_name: str) -> str:

        config = component.descriptor['gce']

        pd_settings = ''
        pd = config.get('persistent_disk')
        if pd:
            pd_settings += '--disk=auto-delete=no,boot=no'
            pd_settings += ',device-name={}'.format(pd['device_name'])
            pd_settings += ',mode={}'.format(pd['mode'])
            pd_settings += ',name={}'.format(pd['name'])

        # If a reservation name is supplied, force the instance-template to use it.
        reservation_affinity_setting = ''
        reservation_name_setting = ''
        res_name = config.get('reservation_name')
        if res_name:
            reservation_affinity_setting += '--reservation-affinity=specific'
            reservation_name_setting     += '--reservation={}'.format(res_name)

        cmd = "gcloud beta compute instance-templates create \
                {instance_template_name} \
                --project={project} \
                --region={region} \
                --machine-type={machine_type} \
                --boot-disk-size={boot_disk_size} \
                --boot-disk-type=pd-standard \
                --image-project=cos-cloud \
                --image-family=cos-stable \
                --tags={tags} \
                --labels=code_version={version} \
                --service-account={service_account} \
                --scopes=https://www.googleapis.com/auth/cloud-platform \
                {network_config} {persistent_disk} {reservation_affinity} {reservation_name} \
                --metadata-from-file=user-data={cloud_init_path}".format(
                    instance_template_name = service_name,
                    project                = self.project_id,
                    region                 = config['region'],
                    machine_type           = config['machine_type'],
                    boot_disk_size         = config['disk_size_gb'],
                    network_config         = self._build_network_config(config),
                    persistent_disk        = pd_settings,
                    reservation_affinity   = reservation_affinity_setting,
                    reservation_name       = reservation_name_setting,
                    service_account        = config['service_account'],
                    version                = template_version,
                    tags                   = ",".join(config['default_network_tags']),
                    cloud_init_path        = cloud_init_path)

        return cmd

    def _update_instance_group_if_needed(self, component, instance_group):
        """ Perform any necessary updates on the instance group.  Right now,
            the only thing we support is changes to the instance group size
        """
        config = component.descriptor['gce']

        if component.descriptor['gce'].get('autoscaling'):
            logging.info(
                'Instance group %s: autoscaling is enabled; skipping group size check.',
                component.name)
            return ''

        # GCE refers to the 'targetSize' as opposed to the _actual_ size
        # of the instance group, in order to account for things like
        # autoscaling that can cause these things to be different.
        # For our manually-scaled instance groups, we'll refer to a
        # "requested target size", indicating that this is what we want GCE
        # to want the group size to be, if that makes sense...
        # We compare against GCE's actual target size and apply changes if
        # they do not match.
        requested_target_size = config['instance_group_size']
        actual_target_size = instance_group['targetSize']
        if actual_target_size == requested_target_size:
            return ''

        logging.info(
                'Updating size of instance group %s from %d to %d',
                component.name,
                actual_target_size,
                requested_target_size)

        cmd = """
            gcloud beta compute instance-groups managed resize \
            {instance_group_name} \
            --size {target_size} \
            {zone_or_region} \
            --project {project}
            """.format(
                    instance_group_name=component.name,
                    target_size=requested_target_size,
                    zone_or_region=self._zone_or_region_arg(component),
                    project=self.project_id)

        return cmd


    def _rolling_update_instance_template(self, component, instance_template_name, instance_group):
        """ Perform a rolling update of the existing instance group with the new template.
            See: https://cloud.google.com/compute/docs/instance-groups/updating-managed-instance-groups#starting_a_basic_rolling_update
        """
        config = component.descriptor['gce']

        recreate_on_replace = config.get('recreate_on_replace', False)
        replace_method_arg = '--replacement-method=recreate' if recreate_on_replace else ''

        # Choose the max-surge parameter.  Ideally we would set this as a fraction
        # of the instance group, and google does technically allow this, but only
        # for groups with > 10 instances.  If this group is large enough, we'll
        # do that, otherwise, we'll set to the maximium of:
        #   - the number of zones enabled (this is a hard minimum)
        #   - the specified instance group size
        #   - the actual instance group size
        # We don't generally expect to use very large instance groups, to deploy
        # very often, or for deploys to take much time, so we're not overly
        # concerned about the groups growing too big during the update.
        #
        # If we use the recreate replacement method, max_surge must be 0.
        # https://cloud.google.com/compute/docs/instance-groups/rolling-out-updates-to-managed-instance-groups#replacement_method

        max_surge = None
        if recreate_on_replace:
            max_surge = 0
        elif instance_group.get('targetSize', 0) > 10:
            max_surge = '80%'
        else:
            max_surge = max(
                1,
                len(config.get('zones', [])),
                config.get('instance_group_size', 1),
                instance_group.get('targetSize', 1)
            )

        # If using recreate_on_replace set max_unavailable to 1, basically stopping an
        # instance, bringing a new one up, and then moving on to the next in the group.
        #
        # Otherwise, set the maxUnavailable parameter to 0, which will prevent GCE from
        # allowing a state in which no instances are available for querying
        # (we believe that we have entered such a state in the past when we
        # have rolled updates to instance groups containing only 1 instance,
        # or only 1 instance per zone).  Note that the only apparent downside
        # to setting this to 0 is that this maximizes the size of the
        # instance group during the rolling update.  But generally our instance
        # groups are all quite small, so this seems like it should not create
        # any real problems?
        # Make this a variable so that we can easily add more logic to it at
        # some future time.
        # see: https://cloud.google.com/compute/docs/instance-groups/rolling-out-updates-to-managed-instance-groups#max_unavailable
        max_unavailable = 1 if recreate_on_replace else 0

        cmd = """
            gcloud beta compute instance-groups managed \
            rolling-action start-update {instance_group_name} \
            --version template={instance_template_name} \
            --max-surge {max_surge} \
            --max-unavailable {max_unavailable} \
            {zone_or_region} \
            {replacement} \
            --project {project}
            """.format(instance_group_name=component.name,
                       instance_template_name=instance_template_name,
                       replacement=replace_method_arg,
                       max_surge=max_surge,
                       max_unavailable=max_unavailable,
                       zone_or_region = self._zone_or_region_arg(component),
                       project=self.project_id)

        return cmd

    @staticmethod
    def _zone_or_region_arg(component):
        config = component.descriptor['gce']

        if config.get('zone'):
            return '--zone ' + config['zone']
        else:
            return '--region ' + config['region']

    def _create_instance_group(self, component, service_name):
        # if creating a regional group, we must pass --zones as a separate
        # comma-separated parameter.  So construct it as an optional parameter
        # (that is empty if not used) and include it in the template.
        optional_zones = ''
        if component.descriptor['gce'].get('zones'):
            optional_zones = '--zones ' + ','.join(
                component.descriptor['gce'].get('zones', [])
            )

        autohealing_settings = []
        autohealing = component.descriptor['gce'].get('autohealing')
        if autohealing:
            autohealing_settings += [
                '--health-check', autohealing['health_check_name']
            ]

            initial_delay = autohealing.get('initial_delay_sec')
            if initial_delay is not None:
                autohealing_settings += [
                    '--initial-delay', str(initial_delay)
                ]

        cmd = """
            gcloud compute instance-groups managed create \
                {instance_group_name}\
                --project={project} \
                --template={instance_template_name}\
                --size {instance_group_size} \
                {zone_or_region} {optional_zones} \
                {optional_autohealing_config}""".format(
                        project=self.project_id,
                        instance_group_name=component.name,
                        instance_template_name=service_name,
                        instance_group_size=component.descriptor['gce']['instance_group_size'],
                        zone_or_region=self._zone_or_region_arg(component),
                        optional_zones=optional_zones,
                        optional_autohealing_config=' '.join(autohealing_settings))

        return cmd

    def _attach_load_balancer_to_instance_group(self, component):
        instance_group_region_or_zone = None
        if component.descriptor['gce'].get('zones'):
            instance_group_region_or_zone = (
                '--instance-group-region ' + component.descriptor['gce']['region']
            )
        else:
            instance_group_region_or_zone = (
                '--instance-group-zone ' + component.descriptor['gce']['zone']
            )

        cmd = """
            gcloud compute backend-services add-backend {backend_name} \
            --project {project} \
            --instance-group {instance_group_name} \
            {instance_group_region_or_zone} \
            --region us-central1 \
            --balancing-mode CONNECTION
            """.format(project=self.project_id,
                       backend_name=component.name,
                       instance_group_name=component.name,
                       instance_group_region_or_zone=instance_group_region_or_zone)

        return cmd

    def build_gcloud_deploy_args(self, component, tmp_cloud_init_path, session, delete_template = False):
        template_version = util.encode_version(component.code_version)
        service_name = self.build_service_version_name(component)

        gcloud_args = []

        if delete_template and self._check_if_instance_template_exists(service_name, session):
            gcloud_args.append(self._delete_instance_template(
                                        component,
                                        template_version,
                                        service_name ))

        gcloud_args.append(self._create_instance_template(
                                        component,
                                        tmp_cloud_init_path,
                                        template_version,
                                        service_name ))

        instance_group = self._get_instance_group(component, session)
        if instance_group:
            gcloud_args.append(self._update_instance_group_if_needed(component, instance_group))
            gcloud_args.append(self._rolling_update_instance_template(component, service_name, instance_group))
        else:
            gcloud_args.append(self._create_instance_group(component, service_name))
            gcloud_args.append(self._attach_load_balancer_to_instance_group(component))

        return [self.prettify_output(arg) for arg in gcloud_args]

    def _needs_stable_wait(self, component):
        return component.descriptor['gce'].get('recreate_on_replace', False)

    def _create_stable_wait_command(self, component):
        zone_or_region_arg = None
        if component.descriptor['gce'].get('zones'):
            zone_or_region_arg = (
                '--region=' + component.descriptor['gce']['region']
            )
        else:
            zone_or_region_arg = (
                '--zone=' + component.descriptor['gce']['zone']
            )

        cmd = """
                    gcloud --project {project} \
                    compute instance-groups managed wait-until --stable \
                    --timeout=420 \
                    {instance_group_name} \
                    {zone_or_region_arg}
                    """.format(project=self.project_id,
                               instance_group_name=component.name,
                               zone_or_region_arg=zone_or_region_arg)

        return cmd

    def _run_gcloud_deploy_args(self, gcloud_args, workdir):
        for arg in gcloud_args:
            subprocess.check_call(arg, cwd=workdir, shell=True)

    def _deploy_with_rendered_cloud_init_yaml(
            self,
            component,
            rendered_cloud_init_yaml,
            dry_run,
            workdir,
            session):

        logging.info(
            'Deploying gce service %s: %s',
            component.name,
            component.code_version)

        tmp_cloud_init_path = os.path.join(workdir, 'cloud-init.yaml')
        with open(tmp_cloud_init_path, 'w') as _out:
            _out.write(rendered_cloud_init_yaml)

        gcloud_args = self.build_gcloud_deploy_args(
            component,
            tmp_cloud_init_path,
            session)

        if dry_run:
            logging.info('  dry run: Skipping execution of gcloud command `%s`', gcloud_args)
            return

        try:
            logging.info('Running these gcloud commands `%s`', gcloud_args)
            self._run_gcloud_deploy_args(gcloud_args, workdir)

        except Exception as e:
            logging.warning("Building gcloud deploy args failed with error {}. Deleting {} template and trying again".format(
                e, component.name))

            gcloud_args = self.build_gcloud_deploy_args(
                component,
                tmp_cloud_init_path,
                session,
                delete_template = True)

            self._run_gcloud_deploy_args(gcloud_args, workdir)

        if self._needs_stable_wait(component):
            logging.info('Waiting for instance group to become stable')
            wait_cmd = self._create_stable_wait_command(component)
            logging.info('Executing wait command `%s`', self.prettify_output(wait_cmd))
            self._run_gcloud_deploy_args([wait_cmd], workdir)

    def _validate_cloud_init_yaml(self, component, rendered_cloud_init_yaml):
        """ For now, just do some simple validation: make sure that the
            rendered cloud_init.yaml file is a valid yaml file.  It is
            conceivable that we could add more rigorous checks in the
            future, especially if we apply more standardized structure to the
            cloud-init.yaml files.
        """
        loaded = yaml.safe_load(rendered_cloud_init_yaml)

    def _do_deploy(self, component, existing_versions, workdir, dry_run):
        rendered_cloud_init_yaml = self._render_config_template(
                component=component,
                template_path=self.build_cloud_init_path(component))

        self._validate_cloud_init_yaml(component, rendered_cloud_init_yaml)

        # We are gradually moving all of this away from making subprocess
        # calls to gcloud, in favor of direct API calls.  So, create an
        # authorized requests session.
        session = (
            Authorizer.read_only() if dry_run else Authorizer.read_write()
        ).get_access_session()

        self._deploy_with_rendered_cloud_init_yaml(
                component = component,
                rendered_cloud_init_yaml = rendered_cloud_init_yaml,
                dry_run = dry_run,
                workdir = workdir,
                session = session)

        # If we've made it here, then the instance group was created
        # and/or updated successfully, and now we have to apply the autoscaler
        # settings, in case they have changed.

        AutoscalingManager(self.project_id, session).update_autoscaler(component, dry_run)
