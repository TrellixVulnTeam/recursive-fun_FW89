import base64
import json
import logging
import marshmallow as ma
import os
import six
from .base import StrictSchema
from stallion.auth import authorizer

# Creates an API client for the KMS API.
_kms_client = None
def _get_kms_client():
    global _kms_client
    result = _kms_client or googleapiclient.discovery.build('cloudkms', 'v1')
    _kms_client = result

    return result

# Ciphertext needs to be base64-encoded KMS-encrypted secret
def _decrypt_with_kms(project, location, keyring, key, ciphertext, session=None):
    if not project or not location or not keyring or not key:
        raise ValueError('Expected project, location, keyring, key. Got project: {}, location: {}, keyring: {}, key: {}')

    # The resource name of the CryptoKey.
    key_name = 'projects/{}/locations/{}/keyRings/{}/cryptoKeys/{}'.format(
        project, location, keyring, key)

    kms_decrypt_endpoint = 'https://cloudkms.googleapis.com/v1/{name}:decrypt'.format(name=key_name)

    session = session or authorizer.get_access_session()
    response = session.post(
            kms_decrypt_endpoint,
            json={'ciphertext': ciphertext})

    if response.status_code != 200:
        raise Exception('Error decrypting secret. Request sent to endpoint: {} with JSON payload: {}. Response from Google KMS API: {}'.format(kms_decrypt_endpoint, json.dumps({'ciphertext': ciphertext}), response.content))

    plaintext = base64.b64decode(response.json()['plaintext'].encode('ascii'))
    return plaintext


def _encrypt_with_kms(project, location, keyring, key, plaintext, session=None):
    if not project or not location or not keyring or not key:
        raise ValueError('Expected project, location, keyring, key. Got project: {}, location: {}, keyring: {}, key: {}')

    # The resource name of the CryptoKey.
    name = 'projects/{}/locations/{}/keyRings/{}/cryptoKeys/{}'.format(
        project, location, keyring, key)

    session = session or authorizer.get_access_session()
    response = session.post(
            'https://cloudkms.googleapis.com/v1/{name}:encrypt'.format(name=name),
            json={'plaintext': base64.b64encode(plaintext).decode('ascii')})

    if response.status_code != 200:
        raise Exception('Error encrypting secret: {}'.format(response.content))

    # Use the KMS API to encrypt the data.
    ciphertext = response.json()['ciphertext']
    return ciphertext



def _get_kms_key(context):
    kms_key_data = context.get('kms_key')
    return kms_key_data

class Secret(StrictSchema):
    """ Schema for encrypted secrets.  The ciphertext is expected to be a
        base64-encoded KMS-encrypted secret.  If the schema's context contains
        a KMS key schema, then the secret will be automatically decrypted
        upon load.  For example:

        key_data = {
        'project' : 'etsy-dataeng-hadoop-sandbox',
        'location' : 'global',
        'keyring': 'test',
        'key': 'quickstart'}

        secret_schema = Secret(context={'kms_key':key_data})
        loaded = secret_schema.load({'ciphertext': ciphertext, 'name': 'mysecret'})

        After these are executed, loaded.data contains a 'plaintext' field
        containing the decrypted secret.

        Note that the decryption step will be skipped if the KMS key info isn't
        present, which is useful for enabling pass-through services, e.g.
        Jenkins, to move the secret from one place to another without requiring
        access to the key.

        Also note that the schema's dump() method will encrypt the secret
        if the key is provided, and automatically discard the plaintext
        from the serialized output.

        Finally, note that by handling the encryption/decryption at the schema
        level, we can encrypt/decrypt many secrets all in a single step, because
        the key context will be passed to all nested Secrets anywhere
        in a service's greater schema definition.
    """
    name = ma.fields.String(required=True)
    ciphertext = ma.fields.String(required=True)
    plaintext = ma.fields.String(load_only=True)

    # Provide an optional field for the kms key to use to decrypt this secret.
    # if not provided, then a KMS key must be supplied in the deserialization
    # context in order to decrypt the secret.  This option allows us to use a
    # shared kms key if we have many secrets present, or individual kms keys
    # per secret, if we prefer to do it that way.
    kms_key = ma.fields.Dict()

    @ma.post_load
    def decrypt(self, data):
        if not self.context.get('decrypt_secrets'):
            logging.debug('Not decrypting secret %s because decrypt_secrets '
                    'is not specified in the deserializer context',
                    data['name'])
            return data

        if 'plaintext' in data:
            logging.debug('Not decrypting secret `%s` because plaintext is '
                    'already present',
                    data['name'])
            return data

        decrypt_method = self.context.get('decrypt_method', _decrypt_with_kms)

        if decrypt_method == _decrypt_with_kms:
            kms_key = _get_kms_key(data) or _get_kms_key(self.context)

            if not kms_key:
                logging.debug('Not decrypting secret `%s` because KMS key info not provided', data.get('name'))
                return data

            plaintext = _decrypt_with_kms(kms_key.get('project'), kms_key.get('location'), kms_key.get('keyring'), kms_key.get('key'), data['ciphertext'])

        else:
            plaintext = decrypt_method(data)

        if data.get('output_filename'):
            # Implement the logic for SecretFile schema here, because we cannot
            # guarantee execution order of multiple distinct post_load methods

            # TODO: be careful about overwriting files upon repeated loads
            # of the config.  Check for differences before writing?  And write
            # to a temporary location first?
            with open(data['output_filename'], 'w') as _out:
                _out.write(plaintext)

        copy = data.copy()
        if self.context.get('deserialize_plaintext') or not data.get('output_filename'):
            copy['plaintext'] = plaintext

        return copy

    @ma.pre_dump
    def encrypt(self, data):
        if not self.context.get('reencrypt_secrets'):
            logging.debug('Not re-encrypting secret %s because '
                    'reencrypt_secrets is not specified in the serializer '
                    'context')
            return data

        encrypt_method = self.context.get('encrypt_method', _encrypt_with_kms)

        if encrypt_method == _encrypt_with_kms:
            kms_key = _get_kms_key(data) or _get_kms_key(self.context)

            # If key exists, encrypt the plaintext with the key. If key doesn't exist, ciphertext is expected to be in the data. In that case, let ciphertext pass through without doing anything.
            if not kms_key and 'ciphertext' not in data:
                raise ma.ValidationError(('Cannot serialize secret {}: KMS key info not defined '
                    'and ciphertext not present!').format(data.get('name')))

            if 'ciphertext' not in data and 'plaintext' not in data:
                raise ma.ValidationError(('Cannot serialize secret {}: plaintext and ciphertext '
                    'are both missing!').format(data.get('name')))

            if kms_key:
                if 'plaintext' in data:
                    # Encrypt the plaintext if it is present, even if the ciphertext is
                    # already present. This could come up for instance if we implement
                    # some kind of key rotation, where perhaps we load the ciphertext
                    # with one key and then dump it with another key.
                    logging.info('Encrypting plaintext for secret %s', data['name'])

                    ciphertext = _encrypt_with_kms(kms_key.get('project'), kms_key.get('location'), kms_key.get('keyring'), kms_key.get('key'), data['plaintext'])
                elif 'output_filename' in data and os.path.isfile(data['output_filename']):
                    # To give consistent behavior to the plaintext-reencryption that
                    # is done in the above block, we re-encrypt the plaintext file
                    # if it is present, even if the ciphertext is already present.

                    logging.info('Encrypting file %s for secret %s', data['output_filename'], data['name'])

                    plaintext = None
                    with open(data['output_filename']) as _in:
                        plaintext = _in.read()

                    ciphertext = _encrypt_with_kms(kms_key.get('project'), kms_key.get('location'), kms_key.get('keyring'), kms_key.get('key'), data['plaintext'])
            else:
                ciphertext = data.get('ciphertext')

        else:
            ciphertext = encrypt_method(data)

        # return the data with ciphertext added
        copy = { key: value for (key, value) in six.iteritems(data) if key != 'plaintext' }
        copy['ciphertext'] = ciphertext
        return copy


class SecretFile(Secret):
    """ A convenience class for secrets that are deserialized to files, commonly
        for use by external programs or libraries (e.g. NGINX, auth libraries,
        etc).  If the output_filename is specified then the secret will be
        written to the designated file after it is decrypted.  By default,
        the decrypted secrets will _only_ be written to the file, not returned
        as part of the deserialized schema.  If the decrypted contents are required
        by the service that is reading the config, then the decrypting method
        should pass the value `'deserialize_plaintext': True` as part of its
        context.  e.g.

        SecretFile(context{"keyring": "mykr", "key": "mykey", "deserialize_plaintext": True).load(...)
    """
    output_filename = ma.fields.String(required=True)
