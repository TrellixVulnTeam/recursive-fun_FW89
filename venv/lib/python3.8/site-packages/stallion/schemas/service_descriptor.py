import marshmallow as ma
from stallion.components.manager import ComponentManager
from .base import StrictSchema
from .cloudsql import CloudSqlSchema
from .gce import GceSchema
from .gae import GaeStandardSchema
from .kubernetes import KubernetesSchema
from .dataflow import GoogleCloudDataflowSchema
from .cloud_function import CloudFunctionSchema
from .cloud_run import CloudRunSchema
from .config_backend import ConfigBackendSchema

class DescriptorBaseSchema(StrictSchema):
    """ This is service metadata that we deploy to the runtime config
        service.  It contains essential information for the service to use
        to identify itself or validate the deployed config; it should not
        contain any more than this; the rest of the deploy config is contained
        in the ServiceDescriptorDeploySchema, below.
    """
    component_type = ma.fields.String(required = True)
    component_settings = ma.fields.Dict()
    kms_key = ma.fields.Dict()
    deployment_type = ma.fields.String()
    config_backend = ma.fields.Nested(ConfigBackendSchema)


class ConfigDescriptorSchema(DescriptorBaseSchema):
    """ This is schema for the Configuration objects as they appear in the
        project-level config files.  The fields in the base schema are deployed
        to RuntimeConfigurator.  Any extra fields in here are only available
        and used at deploy-time.
    """
    name = ma.fields.String(required = True)
    path = ma.fields.String(required = True)


class ServiceDescriptorDeploySchema(DescriptorBaseSchema):
    """ This is the schema used for the Service objects as they appear in the
        project-level config files.  The fields in the base schema are deployed
        to RuntimeConfigurator.  Any extra fields in here are only available
        and used at deploy-time.
    """
    name = ma.fields.String(required = True)
    path = ma.fields.String(required = True)
    code_version = ma.fields.String(required = True)
    disabled = ma.fields.Boolean()

    cloudsql = ma.fields.Nested(CloudSqlSchema())
    deploy_vars = ma.fields.Dict()

    # TODO: schema implementations should be bound to deployers,
    # with a generic `properties` field at the service-descriptor
    # level.
    gae_standard = ma.fields.Nested(GaeStandardSchema())
    gce = ma.fields.Nested(GceSchema())
    cloud_function = ma.fields.Nested(CloudFunctionSchema())
    cloud_run = ma.fields.Nested(CloudRunSchema())
    dataflow = ma.fields.Nested(GoogleCloudDataflowSchema())
    kubernetes = ma.fields.Nested(KubernetesSchema())

    @ma.validates_schema
    def check_deployment_type(self, data):
        from stallion.deploy.deployers import _ALL_DEPLOYERS_TYPE_MAPPING
        from stallion.deploy import gae
        from stallion.deploy.gce import ComputeEngineDeployer
        from stallion.deploy.cloud_function import CloudFunctionDeployer
        from stallion.deploy.cloud_run import CloudRunDeployer
        from stallion.deploy.dataflow import DataflowJavaStreamingPipelineDeployer
        from stallion.deploy.kubernetes import GKEHelmDeployer
        # make sure we check whether deployment_type is in data, to avoid
        # a KeyError inside the validation routine
        if 'deployment_type' not in data:
            return

        if data['deployment_type'] not in _ALL_DEPLOYERS_TYPE_MAPPING :
            raise ma.ValidationError('Not an allowed service type.  Expected one of `{}`'.format(
                '`, `'.join(list(_ALL_DEPLOYERS_TYPE_MAPPING.keys()))),
                [ data['deployment_type'] ])

        if data.get('gae_standard') and \
                data['deployment_type'] not in frozenset([
                        gae.AppEngineStandardDeployer.type,
                        gae.AppEngineBaseAppDeployer.type]):
            raise ma.ValidationError('Found gae_standard deployer config {} '
                    'which is incompatible with this deployment type'.format(
                        data['gae_standard']),
                    [ data['deployment_type'] ])

        if data.get('gce') and \
                data['deployment_type'] != ComputeEngineDeployer.type:
            raise ma.ValidationError('Found gce deployer config {} '
                    'which is incompatible with this deployment type'.format(
                        data['gce']),
                    [ data['deployment_type'] ])

        if data.get('cloud_function') and \
                data['deployment_type'] != CloudFunctionDeployer.type:
            raise ma.ValidationError('Found cloud_function deployer config {} '
                    'which is incompatible with this deployment type'.format(
                        data['cloud_function']),
                    [ data['deployment_type'] ])

        if data.get('cloud_run') and \
                data['deployment_type'] != CloudRunDeployer.type:
            raise ma.ValidationError('Found cloud_run deployer config {} '
                    'which is incompatible with this deployment type'.format(
                        data['cloud_run']),
                    [ data['deployment_type'] ])

        if data.get('dataflow') and \
                data['deployment_type'] != DataflowJavaStreamingPipelineDeployer.type:
            raise ma.ValidationError('Found dataflow deployer config {} '
                    'which is incompatible with this deployment type'.format(
                        data['dataflow']),
                    [ data['deployment_type'] ])

        if data.get('kubernetes') and \
                data['deployment_type'] not in frozenset([GKEHelmDeployer.type]):
            raise ma.ValidationError('Found dataflow deployer config {} '
                    'which is incompatible with this deployment type'.format(
                        data['kubernetes']),
                    [ data['deployment_type'] ])


    @ma.validates_schema
    def check_component_type(self, data):
        mgr = ComponentManager()
        if 'component_type' not in data:
            return

        if data['component_type'] not in mgr.component_type_mapping:
            raise ma.ValidationError('Not an allowed service type.  Expected one of `{}`'.format(
                '`, `'.join(list(mgr.component_type_mapping.keys()))),
                [ data['component_type'] ])
