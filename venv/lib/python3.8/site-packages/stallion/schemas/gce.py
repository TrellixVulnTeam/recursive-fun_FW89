import marshmallow as ma
from .base import StrictSchema

class NetworkInterfaceConfig(StrictSchema):
    network = ma.fields.String(required=True)
    subnet = ma.fields.String(required=True)

class CustomMetricUtilizationSchema(StrictSchema):
    metric = ma.fields.String(required=True)

    utilization_target = ma.fields.Float(
        required=True,
        validate=ma.validate.Range(min=0.0)
    )

    utilization_target_type = ma.fields.String(
        required=True,
        validate=ma.validate.OneOf([
            'DELTA_PER_MINUTE',
            'DELTA_PER_SECOND',
            'GAUGE'
        ]))

class PersistentDiskSchema(StrictSchema):
    # Support for adding *EXISTING* persistent disks (PDs)

    name = ma.fields.String(required=True)
    device_name = ma.fields.String(required=True)
    mode = ma.fields.String(
        required=True,
        validate=ma.validate.OneOf([
            'rw',
            'ro'
        ])
    )

class AutoscalingSchema(StrictSchema):
    # Full support for all autoscaling options. See:
    # https://cloud.google.com/compute/docs/reference/rest/v1/autoscalers/insert
    # Note: required fields 'name' and 'target' are auto-filled by stallion

    min_num_replicas = ma.fields.Integer(
        validate=ma.validate.Range(min=1)
    )

    max_num_replicas = ma.fields.Integer(
        required=True,
        validate=ma.validate.Range(min=2)
    )

    cool_down_period_sec = ma.fields.Integer(
        validate=ma.validate.Range(min=60)
    )

    cpu_utilization_target = ma.fields.Float(
        validate=ma.validate.Range(min=0.0, max=1.0)
    )

    load_balancing_utilization_target = ma.fields.Float(
        validate=ma.validate.Range(min=0.0)
    )

    custom_metric_utilizations = ma.fields.List(
        ma.fields.Nested(CustomMetricUtilizationSchema)
    )


    @ma.validates_schema
    def valid_num_replica_range(self, data):
        # Note: I'm not 100% sure whether we can assume that the required
        # field `max_num_replicas` is necessarily in `data` at this point.
        # It depends on marshmallow's rules regarding when it runs validators
        # and whether it stops at the first failure or continues through all
        # validators before reporting the error.  To be safe, we take default
        # values for both parameters that will be guaranteed to generate
        # failures.
        if data.get('max_num_replicas', 0) <= data.get('min_num_replicas', 1):
            raise ma.ValidationError(
                'max_num_replicas must be > min_num_replicas',
                ['max_num_replicas', 'min_num_replicas'],
            )


class AutohealingSchema(StrictSchema):
    health_check_name = ma.fields.String(required=True)
    initial_delay_sec = ma.fields.Integer()


class GceSchema(StrictSchema):
    region = ma.fields.String(required = True)

    zone = ma.fields.String()
    zones = ma.fields.List(ma.fields.String())

    instance_group_size = ma.fields.Integer(required = True)
    autoscaling = ma.fields.Nested(AutoscalingSchema)
    autohealing = ma.fields.Nested(AutohealingSchema)

    image_version = ma.fields.String() # this is not actually used!

    machine_type = ma.fields.String(required = True)
    disk_size_gb = ma.fields.Integer(required = True)

    # Note: let's deprecate the default_network_uri and default_subnetwork_uri
    # in favor of the network_interfaces field, which supports instances with
    # multiple interfaces
    default_network_uri = ma.fields.String()
    default_subnetwork_uri = ma.fields.String()

    network_interfaces = ma.fields.List(ma.fields.Nested(NetworkInterfaceConfig))

    default_network_tags = ma.fields.List(ma.fields.String(), missing = [])

    service_account = ma.fields.String(required = True)

    persistent_disk = ma.fields.Nested(PersistentDiskSchema)

    recreate_on_replace = ma.fields.Boolean()

    reservation_name = ma.fields.String()

    @ma.validates_schema
    def validate_pd_mode(self, data):
        # Mode can not be rw if total instances are > 1
        pd = data.get('persistent_disk')
        if pd and pd.get('mode') == 'rw' and data.get('instance_group_size') > 1:
            raise ma.ValidationError("PD mode can't be rw if group_size is greater than 1")

    @ma.validates_schema
    def validate_zones(self, data):
        if not data.get('zone') and not data.get('zones'):
            raise ma.ValidationError(
                'Must specify one or more GCE zones', ['zone', 'zones'])

        if data.get('zone') and data.get('zones'):
            raise ma.ValidationError(
                'Must specify only one of the parameters `zone`, `zones`',
                ['zone', 'zones'])

        if len(data.get('zones', [])) == 1:
            raise ma.ValidationError(
                'Please use the `zone` argument for zonal instance groups (`zones` is for regional groups)',
                ['zones'])

        region = data.get('region')
        if not region:
            # will be handled by the `required` validator
            return

        zones = [_f for _f in [data.get('zone')] + data.get('zones', []) if _f]

        bad_zones = [ zone for zone in zones if not zone.startswith(data.get('region')) ]
        if bad_zones:
            raise ma.ValidationError(
                'One or more zones are incompatible with the specified region `{}`: `{}`'.format(
                    region,
                    bad_zones)
                )

    @ma.validates_schema
    def validate_networks(self, data):
        """ Make sure that at least one network was specified """
        if data.get('default_network_uri') and data.get('default_subnetwork_uri'):
            return

        if data.get('default_network_uri') or data.get('default_subnetwork_uri'):
            raise ma.ValidationError(
                    'Incomplete network configuration: default_network_uri and '
                    'default_subnetwork_uri must be provided together, or not '
                    'at all',
                    ['network_interfaces'])

        if not data.get('network_interfaces'):
            raise ma.ValidationError(
                    'No network configuration provided!',
                    ['network_interfaces'])
