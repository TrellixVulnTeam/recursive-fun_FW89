import six
import marshmallow as ma

from stallion.schemas.base import StrictSchema

from stallion import util
from .base import ConfigBackendBase


class LocalDictPropertiesSchema(StrictSchema):
    initial_state = ma.fields.Dict()


class LocalDictConfigBackend(ConfigBackendBase):
    """ A local dictionary-backed config backend.  Mostly for unit testing. """
    name = "local_dict"
    properties_schema = LocalDictPropertiesSchema()

    def __init__(self, properties):
        super(LocalDictConfigBackend, self).__init__(properties)
        self.state = self.properties.get('initial_state', {})

        # to help enable the use of this in unit tests, we will keep track of
        # the call count for the get_component_config() method
        self.call_count = 0

    def get_component_config(
            self,
            component_name,
            component_version,
            subtree=None):
        """ Retrieve the configuration for the specified component.

            :param component_name: the name of the component
            :type component_name: str
            :param component_version: the version of the component
            :type component_version: str
            :param subtree: if specified, then the config will be pruned to include
                only the specified subtree
            :type subtree: list<str>

            :return the component's configuration, in its fully nested form
            :rtype dict
        """
        self.call_count += 1

        config = self.state.get(component_name, {}).get(component_version, {})
        result = config if not subtree else util.dict_subtree(config, subtree)

        return result.copy() if isinstance(result, dict) else result


    def _write_component_config(
            self,
            component_name,
            component_version,
            item,
            strict,
            **kwargs):
        """ Write the provided component config into the backend data store.

            :param component_name: the name of the component
            :type component_name: str
            :param component_version: the version of the component
            :type component_version: str
            :param item: the config to write
            :type item: dict
            :param strict: if true, then consider the provided item to be the
                exact value to store for the specified component.  If false,
                then treat this item as a patch to merge into any existing
                config.
            :type strict: bool

            :return nothing
            :rtype NoneType
        """
        if strict:
            to_store = item
        else:
            to_store = self.get_component_config(component_name, component_version)
            for (key, value) in six.iteritems(item):
                to_store[key] = value

        self.state.setdefault(component_name, {})
        self.state[component_name][component_version] = to_store


    def list_component_versions(
            self,
            component_name,
            **kwargs):
        """ List the available config versions for the named component

            :param component_name: the name of the component
            :type component_name: str

            :return the available versions
            :rtype frozenset<str>
        """
        return frozenset(list(self.state.get(component_name, {}).keys()))


    def delete_component_version(
            self,
            component_name,
            component_version,
            **kwargs):
        """ Delete the specified component

            :param component_name: the name of the component
            :type component_name: str
            :param component_version: the version of the component
            :type component_version: str

            :return nothing
            :rtype NoneType
        """
        versions = self.state.get(component_name, {})
        versions.pop(component_version)

        if not versions:
            self.state.pop(component_name)
