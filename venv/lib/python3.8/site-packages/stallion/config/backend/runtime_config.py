from builtins import map
from builtins import str
from builtins import object
import re
import operator
import base64
import logging
import json
import six

import marshmallow as ma
from stallion.schemas.base import StrictSchema

from stallion.config.backend.base import ConfigBackendBase
from stallion.config.flatten_utils import flatten, unflatten
from stallion.auth import authorizer
from stallion import util, exceptions

API_BASE_URI = "https://runtimeconfig.googleapis.com/v1beta1"
NONE_VALUE_INDICATOR = 'N---'
RESERVED_VALUES = frozenset([ NONE_VALUE_INDICATOR ])

VARIABLE_NAME_TEMPLATE = "projects/{project_id}/configs/{component_name}/variables/{component_version}/{variable_name}"
VARIABLE_NAME_PATTERN = VARIABLE_NAME_TEMPLATE.format(
    project_id='([a-z0-9A-Z-]+)',
    component_name='([a-z0-9A-Z-]+)',
    component_version='([^/]+)',
    variable_name='([a-zA-Z0-9/.-]+)')
VARIABLE_NAME_RE = re.compile(VARIABLE_NAME_PATTERN)

def _project_config_path(project_id):
    return 'projects/{project_id}/configs'.format(project_id=project_id)

def _base_config_uri(project_id):
    return API_BASE_URI + '/' + _project_config_path(project_id)

def _component_config_path(project_id, component_name):
    return _project_config_path(project_id) + '/' + component_name

def _component_config_uri(project_id, component_name):
    return _base_config_uri(project_id) + '/' + component_name

def _component_variables_uri(project_id, component_name):
    return _component_config_uri(project_id, component_name) + '/variables'

def _variable_base_name(project_id, component_name, component_version):
    # Note: variable_base_name must end in a trailing slash because we want
    # to strip that slash out as well as include it when we send filters
    # with requests

    return _component_config_path(project_id, component_name) + \
            '/variables/' + component_version + '/'

class RuntimeConfigVariable(object):
    def __init__(
            self,
            project_id,
            component_name,
            component_version,
            name,
            text,
            value):
        self.project_id = project_id
        self.component_name = component_name
        self.component_version = component_version

        self.name = name
        self.value = value
        self.text = text

        assert name.startswith(self.base_name()), \
                'Error: variable name `{}` does not start with the expected pattern `{}`'.format(
                        self.name,
                        self.base_name())


    @classmethod
    def from_api_response(cls, response):
        match = VARIABLE_NAME_RE.match(response['name'])
        if not match:
            raise ValueError('Invalid variable name: {} (expected pattern {})'.format(
                response['name'],
                VARIABLE_NAME_PATTERN))

        return cls(
                project_id=match.group(1),
                component_name=match.group(2),
                component_version=match.group(3),
                name=response['name'],
                text=response.get('text'),
                value=response.get('value'))


    @classmethod
    def from_component_key_value(cls, project_id, component_name, component_version, key, value):
        name = VARIABLE_NAME_TEMPLATE.format(
                project_id=project_id,
                component_name=component_name,
                component_version=component_version,
                variable_name=key)

        if value is None or isinstance(value, six.string_types):
            assert value is None or value not in RESERVED_VALUES, \
                'Invalid value `{}`: may not use reserved values `{}`'.format(
                        value, RESERVED_VALUES)

            return cls(
                    project_id=project_id,
                    component_name=component_name,
                    component_version=component_version,
                    name=name,
                    text=value or NONE_VALUE_INDICATOR,
                    value=None)

        return cls(
                project_id=project_id,
                component_name=component_name,
                component_version=component_version,
                name=name,
                text=None,
                value=base64.b64encode(str(value).encode('utf-8')).decode('utf-8'))


    @staticmethod
    def build_filter(project_id, component_name, component_version=None, subtree=None):
        if subtree and not component_version:
            raise ValueError(
                    'Missing component_version is required when specifying a subtree (found subtree: {})'.format(
                        subtree))

        base = '/'.join([_f for _f in [
            _component_config_path(project_id, component_name),
            'variables',
            component_version] if _f]) + '/'

        return base + '/'.join(subtree or [])


    def base_name(self):
        return self.build_filter(
                project_id=self.project_id,
                component_name=self.component_name,
                component_version=self.component_version)


    @property
    def has_value(self):
        return bool(self.text or self.value)


    @property
    def deserialized_value(self):
        item = self.text or (base64.b64decode(self.value).decode('utf-8') if self.value else None)

        return None if item == NONE_VALUE_INDICATOR else item


    @property
    def stripped_name(self):
        return self.name[len(self.base_name()):].lstrip('/')


    def build_update_uri(self):
        return API_BASE_URI + '/' + self.name


    def to_json(self):
        assert self.has_value, \
                'Attempting to serialize a {} without a value. ' \
                'Serialization is usually in preparation for writing to the ' \
                'RuntimeConfigurator service.  This is probably not what you want!'

        response = {'name': self.name}

        if self.value:
            response['value'] = self.value

        if self.text:
            response['text'] = self.text

        return response


    def __eq__(self, that):
        """ Utility method for comparing two variable instances.  Variables returned
            by the API contain an update timestamp that we can't include in the
            comparison
        """
        if not isinstance(that, self.__class__):
            return False

        if not (self.has_value and that.has_value):
            raise Exception('Cannot compare variables {} and {} because one or both are missing values!'.format(
                self, that))

        return self.project_id == that.project_id and \
                self.component_name == that.component_name and \
                self.component_version == that.component_version and \
                self.name == that.name and \
                self.value == that.value and \
                self.text == that.text


    def __repr__(self):
        return '{}({}, {})'.format(
                self.__class__.__name__,
                self.name,
                self.deserialized_value)


    def __hash__(self):
        return hash(self.project_id) ^ \
                hash(self.component_name) ^ \
                hash(self.component_version) ^ \
                hash(self.name) ^ \
                hash(self.value) ^ \
                hash(self.text)


class RuntimeConfigBackendPropertiesSchema(StrictSchema):
    project_id = ma.fields.String(required=True)


class RuntimeConfigBackend(ConfigBackendBase):
    # When we push configs to GCP runtime config and then pull them back in, we
    # can't distinguish between values that are None (ie null / empty / etc) and
    # "None" (the string value).  So we replace None with an indicator string
    # that we look for when we pull the data back out of the config service.

    name = "gcp_runtime_configurator"
    properties_schema = RuntimeConfigBackendPropertiesSchema()

    def __init__(self, properties):
        super(RuntimeConfigBackend, self).__init__(properties)
        self.project_id = self.properties['project_id']

    @staticmethod
    def for_project(project_id):
        return RuntimeConfigBackend({'project_id': project_id})

    def create_component_config_if_not_exists(self, component_name, session=None):
        """ Make sure that the configuration exists for this component """
        session = session or authorizer.get_access_session()
        if self.get_component_config_metadata(component_name, session):
            return

        body = {
                'name': _component_config_path(self.project_id, component_name),
                'description': 'Component configuration'
                }

        uri = _base_config_uri(self.project_id)
        response = session.post(uri, json=body, timeout=10)

        if response.status_code != 200:
            raise Exception('Failed to POST to URI {}'.format(uri))

    def get_component_config_metadata(self, component_name, session=None):
        """ Get component config metadata; used primarily to check whether
            the component exists
        """
        session = session or authorizer.get_access_session()

        uri = _component_config_uri(self.project_id, component_name)

        logging.debug('Checking for existing config `%s` at URI %s',
            component_name, uri)

        metadata = None
        response = session.get(uri, timeout=10)
        if response.status_code == 200:
            logging.debug('Config `%s` exists', component_name)
            metadata = response.json()

        elif response.status_code != 404:
            raise Exception('Could not GET uri {}'.format(uri))

        else:
            logging.debug('Config `%s` does not exist', component_name)

        return metadata

    def _write_component_config(
            self,
            component_name,
            component_version,
            item,
            strict,
            session=None):
        """ Write the component stored in item argument to the RuntimeConfig
            service.  If strict == True, then delete any keys that we find
            in this component's namespace but not in the input item.
        """
        session = session or authorizer.get_access_session()
        self.create_component_config_if_not_exists(component_name, session)

        variables = self.pack(component_name, component_version, item)
        variable_names = frozenset(list(map(operator.attrgetter('name'), variables)))

        existing_variables = util.keyby(
            self._retrieve_variables(
                component_name=component_name,
                component_version=component_version,
                return_values=True,
                subtree=[],
                session=session),
            operator.attrgetter('name'),
            'Retrieving existing variables for {}:{}'.format(
                component_name,
                component_version))

        logging.debug('Retrieved existing variables: %s', existing_variables)

        for variable in variables:
            existing = existing_variables.get(variable.name)

            if existing and variable == existing:
                logging.debug('Not overwriting existing variable %s', existing)
                continue

            if existing:
                logging.debug('Existing variable does not match: %s != %s',
                        existing,
                        variable)


            self._write_variable(
                    variable,
                    session=session,
                    overwrite=existing is not None)

        if not strict:
            return

        to_delete = frozenset(existing_variables) - variable_names
        if not to_delete:
            logging.debug('No variables to delete')

        for variable_name in to_delete:
            self._delete_variable(existing_variables[variable_name], False, session=session)


    def delete_component_version(self, component_name, component_version, session=None):
        session = session or authorizer.get_access_session()

        logging.debug('Deleting configuration for %s:%s', component_name, component_version)

        variable_prefix = RuntimeConfigVariable(
                self.project_id,
                component_name,
                component_version,
                name=RuntimeConfigVariable.build_filter(
                    self.project_id,
                    component_name,
                    component_version),
                text=None,
                value=None)

        self._delete_variable(variable_prefix, True, session)


    def list_component_versions(self, component_name, session=None):
        session = session or authorizer.get_access_session()

        variables = self._retrieve_variables(
                component_name=component_name,
                component_version=None,
                return_values=False,
                subtree=[],
                session=session)

        return frozenset(var.component_version for var in variables)


    def _retrieve_variables(self, component_name, component_version, return_values, subtree, session):
        name_filter = RuntimeConfigVariable.build_filter(
                project_id=self.project_id,
                component_name=component_name,
                component_version=component_version,
                subtree=subtree)

        variables = []
        pageToken = None
        done = False
        while not done:
            query_params = {
                    'filter': name_filter,
                    'returnValues': str(return_values),
                    }

            if pageToken:
                query_params['pageToken'] = pageToken

            response = session.get(
                    _component_variables_uri(self.project_id, component_name),
                    params=query_params,
                    timeout=10)

            if response.status_code == 404:
                raise exceptions.ConfigDoesNotExistException(
                        'Config for {}/{}/{} does not exist!'.format(
                            self.project_id,
                            component_name,
                            component_version,
                            response.status_code))

            elif response.status_code != 200:
                raise Exception('Unknown failure while loading config for {}/{}/{} (response code: {} Contents: {})'.format(
                    self.project_id,
                    component_name,
                    component_version,
                    response.status_code,
                    response.text))

            response_json = response.json()
            pageToken = response_json.get('nextPageToken')
            done = not pageToken

            variables += list(map(RuntimeConfigVariable.from_api_response,
                            response_json.get('variables', [])))


        if not variables:
            logging.warn('No existing configuration found for component {}:{}{} in project {}!'.format(
                component_name,
                component_version,
                '' if not subtree else ('/' + '/'.join(subtree)),
                self.project_id))

        return variables

    def get_component_config(self, component_name, component_version, subtree = None, session=None):
        session = session or authorizer.get_access_session()
        variables = self._retrieve_variables(
                component_name=component_name,
                component_version=component_version,
                return_values=True,
                subtree=subtree or [],
                session=session)
        # strip off the variable base name prefix from all returned variables
        return self.unpack(variables)


    def _write_variable(self, variable, session, overwrite=False):
        # Refuse to write a plaintext variable (shouldn't have made it this far
        # anyway, but a second layer of checks is helpful).  Such a variable
        # will be encoded as a nested Secret, which means that its name will
        # end in '/plaintext'
        if variable.name.endswith('/plaintext'):
            raise Exception('Decrypted plaintext detected in variable %s.', variable.name)

        logging.debug('%s variable %s', 'Updating' if overwrite else 'Creating', variable.name)

        request_uri = variable.build_update_uri() if overwrite else \
                _component_variables_uri(self.project_id, variable.component_name)

        logging.debug('URI is [%s]', request_uri)

        response = session.request(
                'PUT' if overwrite else 'POST',
                request_uri,
                json=variable.to_json(),
                timeout=10)

        if response.status_code != 200:
            raise Exception('Failed to create variable `{}`: {}'.format(
                variable.name, response.content))

        logging.debug('SUCCESSfully wrote variable %s', variable.name)


    def _delete_variable(self, variable, recursive, session):
        logging.debug('Deleting variable %s', variable.name)

        response = session.delete(
                variable.build_update_uri(),
                params={'recursive': str(recursive).lower()},
                timeout=10)

        if response.status_code != 200:
            raise Exception('Failed to delete variable `{}`: {}'.format(
                to_delete, response.content))

        logging.debug('SUCCESSfully deleted variable %s', variable.name)


    @classmethod
    def unpack(cls, variables):
        flat_result = {}
        for variable in variables:
            name = variable.stripped_name
            value = variable.deserialized_value

            # Check for duplicate values; allow duplicates of keys if values match
            assert flat_result.get(name, value) == value, \
                'Duplicate values for variable {}'.format(name)

            flat_result[name] = value

        return unflatten(flat_result, '/')


    def pack(self, component_name, component_version, item):
        flat_item = flatten(item, '/')

        return [
                RuntimeConfigVariable.from_component_key_value(
                    project_id=self.project_id,
                    component_name=component_name,
                    component_version=component_version,
                    key=key,
                    value=value)
                for (key, value) in six.iteritems(flat_item) ]
