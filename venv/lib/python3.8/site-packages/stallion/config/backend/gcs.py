from builtins import object
import os
import json
import datetime
import re
import traceback
import functools
import logging

import marshmallow as ma

from google.cloud import storage
from google.cloud.exceptions import GatewayTimeout
from google.api_core.exceptions import ServiceUnavailable

from stallion.retry import retryable, timeout, TimeoutError
from stallion.schemas.base import StrictSchema

from stallion import util, exceptions
from stallion.config import flatten_utils
from .base import ConfigBackendBase

@functools.total_ordering
class ConfigVersion(object):
    """ A class for managing config versions, used by the GCSConfigBackend.
        Each version has both a version number and a creation timestamp.
        This class implements logic for encoding the version information into
        a path for writing to GCS, as well as for decoding a GCS path back to
        the version it corresponds to.  Additional utility methods are provided
        to ensure that ConfigVersion objects are ordered and sortable, and to
        automatically increment a version to create a new one.
    """
    VERSION_DIR_PREFIX = 'c'

    def __init__(self, number, created=None):
        self.number = number
        self.created = created or datetime.datetime.utcnow()

    def __gt__(self, other):
        """ Implement the greater-than function.  @functools.total_ordering will fill
            in all other comparator operations.
        """
        return self.number > other.number or (
            self.number == other.number and self.created > other.created
        )

    def __eq__(self, other):
        """ Implement equality-checking """
        return self.number == other.number and self.created == other.created

    @property
    def version_dir(self):
        """ Encode the version into a directory """
        return self._format_version_dir(
            self.VERSION_DIR_PREFIX,
            self.number,
            self.created.isoformat())

    @staticmethod
    def _format_version_dir(prefix, number, datestamp):
        """ Method for encoding a prefix, version number and datestamp into a
            directory
        """
        return '{}{}-{}'.format(
            prefix,
            number,
            datestamp)

    @classmethod
    def build_version_regex(cls):
        """ Method to build a regex for decoding a directory back into a ConfigVersion """
        return re.compile(
            cls._format_version_dir(
                cls.VERSION_DIR_PREFIX,
                '(?P<config_number>\d+)',
                '(?P<date_stamp>.*)'
            )
        )

    @staticmethod
    def parse_isodate(date):
        """ Parse an ISO date stamp (e.g. 2019-05-29T00:00:00.12345)
            Note that we want to include support for datestamps with or
            without fractional seconds, and doing so is a little messy because
            python's strptime doesn't allow very flexible formatting strings
            (e.g. there is no way to indicate that a certain portion is
            optional).

            :param date: the datestamp
            :type date: str
        """
        format_without_subsecond = '%Y-%m-%dT%H:%M:%S'
        format_with_subsecond = format_without_subsecond + '.%f'

        result = None
        try:
            result = datetime.datetime.strptime(date, format_with_subsecond)
        except ValueError as ve:
            try:
                result = datetime.datetime.strptime(date, format_without_subsecond)
            except ValueError as ve:
                logging.warn('Failed to parse datestamp `%s`', date)
                pass

        return result

    @classmethod
    def from_version_dir(cls, version_dir, version_regex=None):
        """ Decode a directory name back into a ConfigVersion.
            Uses the provided version_regex, if present, otherwise creates a new one
            using the build_version_regex method, above.  Note that any provided
            version regex should also have been constructed using this method; the
            option to supply it is simply for performance, to avoid re-generating the
            same regular expression repeatedly.
        """
        version_regex = version_regex or cls.build_version_regex()
        hit = version_regex.match(version_dir)
        if not hit:
            return None

        parsed_date = cls.parse_isodate(hit.group('date_stamp'))
        if not parsed_date:
            return None

        return ConfigVersion(
            number = int(hit.group('config_number')),
            created = parsed_date)

    def increment(self):
        """ Produce a new ConfigVersion from this one, with incremented version
            number and current time as the creation time
        """
        return ConfigVersion(self.number + 1)

    def __repr__(self):
        return '{}:{}'.format(self.number, self.created.isoformat())


class GCSBackendPropertiesSchema(StrictSchema):
    """ The schema for the GCSConfigBackend properties """

    # bucket_name is the name of the GCS bucket to use
    bucket_name = ma.fields.String(required=True)

    # path_prefix is a string to prepend onto all of the config filenames
    # written to / read from GCS.  Think of it as like a "directory" in which
    # to store all of the component configs.  If it is not provided, everything
    # is stored in the root of the bucket.
    path_prefix = ma.fields.String()


class GCSConfigBackend(ConfigBackendBase):
    """ A config backend using Google Cloud Storage.
        :param properties: the properties for this config backend instance.  Must
            match the schema defined by GCSBackendPropertiesSchema
        :type properties: dict
        :param client: a google cloud storage python library client instance.
            Generally only supplied in unit tests.
        :type client: google.cloud.storage.Client
    """
    def __init__(self, properties, client=None):
        super(GCSConfigBackend, self).__init__(properties)

        self.client = client or storage.Client()
        self.bucket = self.client.bucket(self.bucket_name)
        self.version_re = ConfigVersion.build_version_regex()
        self.path_prefix = properties.get('path_prefix')

    name = "google_cloud_storage"
    properties_schema = GCSBackendPropertiesSchema()

    config_base_filename = 'config.json'

    @property
    def bucket_name(self):
        return self.properties['bucket_name']

    def config_base_blob_name(self, component_name, component_version):
        """ Construct the basename for the config blob, using this instance's internal
            path prefix, as well as the component name and component version.
            The path basename is portion of the GCS file path prior to the config
            version and filename, for example:

            my-path-prefix/my-component-name/my-component-version

            which will later have the config version and filename appended further.

            :param component_name: the component's name
            :type component_name: str
            :param component_version: the component's version
            :type component_version: str
        """
        return os.path.join(*[_f for _f in [self.path_prefix, component_name, component_version] if _f])

    @retryable((GatewayTimeout, ServiceUnavailable), tries=5, delay=3, backoff=2, logger=logging)
    def _config_file_blob(
            self,
            component_name,
            component_version,
            config_version):
        """ Construct the google.cloud.storage.Blob object for the provided component,
            using this instance's internal path prefix, the component name and version,
            the provided config version, and the config_base_fileame property attached
            to this class.  For example, a complete blob may have the name:

            my-path-prefix/my-component-name/my-component-version/c1-2019-05-28T00:00:00.0/config.json

            :param component_name: the component's name
            :type component_name: str
            :param component_version: the component's version
            :type component_version: str
            :param config_version: the version of the config for this component/version
            :type config_version: ConfigVersion

            :return the blob
            :rtype google.cloud.storage.Blob
        """
        blob_name = os.path.join(
            self.config_base_blob_name(component_name, component_version),
            config_version.version_dir,
            self.config_base_filename)

        return self.bucket.blob(blob_name)

    @retryable((GatewayTimeout, ServiceUnavailable), tries=5, delay=3, backoff=2, logger=logging)
    def _read_config(
            self,
            component_name,
            component_version,
            config_version):
        """ Retrieve the contents of a particular config stored in GCS, and deserialize
            it from JSON into a python dictionary.

            :param component_name: the component's name
            :type component_name: str
            :param component_version: the component's version
            :type component_version: str
            :param config_version: the version of the config to read
            :type config_version: ConfigVersion

            :return the config
            :rtype dict
        """
        blob = self._config_file_blob(component_name, component_version, config_version)
        if not blob.exists():
            raise Exception(
                'Cannot read config {}:{}#{}: file {} does not exist!'.format(
                    component_name,
                    component_version,
                    config_version,
                    blob.name))

        return json.loads(blob.download_as_string().decode('utf-8'))

    @retryable((GatewayTimeout, ServiceUnavailable), tries=5, delay=3, backoff=2, logger=logging)
    def _list_dir(self, directory):
        """ List the contents of a "directory" in GCS.  Equivalent to the `gsutil ls`
            command, but more complicated to implement due to oddities of the
            GCS API.  Uses the bucket bound to this backend.

            :param directory: the directory to list
            :type directory: str

            :return the items within the directory.  Note that the full paths to the
                items are _not_ returned, but rather, only the names of the items
                within the provided directories, are.
            :rtype list<str>
        """
        blob_prefix = directory + os.path.sep
        blob_iter = self.bucket.list_blobs(
            prefix=blob_prefix,
            delimiter=os.path.sep)

        list(blob_iter) # Trigger retrieval of prefixes

        return [
            item[len(blob_prefix):].rstrip(os.path.sep)
            for item in blob_iter.prefixes
        ]

    def _list_config_versions(self, component_name, component_version):
        """ List the config versions present for the specified component.

            :param component_name: the component's name
            :type component_name: str
            :param component_version: the component's version
            :type component_version: str

            :return the config versions found
            :rtype ConfigVersion
        """
        component_dir = self.config_base_blob_name(component_name, component_version)
        config_dirs = self._list_dir(component_dir)

        return [
            ConfigVersion.from_version_dir(dirname, self.version_re)
            for dirname in config_dirs
        ]

    @retryable(TimeoutError, tries=3)  # On TimeoutErrors, retry up to 3 times
    @timeout(600)  # Timeout after 10 mins
    def _read_latest_config(self, component_name, component_version):
        """ Retrieve the contents of the latest available config version for the
            specified component, deserialized from JSON as a python dict.

            Note that any errors in loading one config version will be caught, and
            the loader will fall back to the prior config version, repeating this
            process until either a valid config is found, or the list of available
            versions is exhausted.  Errors will be logged in any cases of loader
            failures.

            :param component_name: the component's name
            :type component_name: str
            :param component_version: the component's version
            :type component_version: str

            :return a tuple containing (the config version retrieved, the config)
            :rtype (ConfigVersion, dict)
        """
        all_versions = sorted(
            self._list_config_versions(component_name, component_version),
            reverse=True)

        version_idx = 0
        config = None
        while version_idx < len(all_versions):
            try:
                config = self._read_config(
                    component_name,
                    component_version,
                    all_versions[version_idx])
                break
            except Exception as e:
                logging.warn(
                    'Error loading version %s for component %s:%s: %s',
                    all_versions[version_idx],
                    component_name,
                    component_version,
                    traceback.format_exc())
                version_idx += 1

        return (
            all_versions[version_idx] if version_idx < len(all_versions) else None,
            config
        )

    @retryable((GatewayTimeout, ServiceUnavailable), tries=5, delay=3, backoff=2, logger=logging)
    def _write_config(
            self,
            component_name,
            component_version,
            config_version,
            config):
        """ Write the provided config into the backend.

            :param component_name: the component's name
            :type component_name: str
            :param component_version: the component's version
            :type component_version: str
            :param config_version: the version of the config for this component/version
            :type config_version: ConfigVersion
        """
        blob = self._config_file_blob(component_name, component_version, config_version)
        if blob.exists():
            raise Exception('ERROR: attempting to overwrite config file {}'.format(
                blob.name))

        blob.upload_from_string(json.dumps(config))

    def get_component_config(
            self,
            component_name,
            component_version,
            subtree=None):
        """ Retrieve the configuration for the specified component.

            :param component_name: the name of the component
            :type component_name: str
            :param component_version: the version of the component
            :type component_version: str
            :param subtree: if specified, then the config will be pruned to include
                only the specified subtree
            :type subtree: list<str>

            :return the component's configuration, in its fully nested form
            :rtype dict
        """
        (config_version, config) = self._read_latest_config(
            component_name,
            component_version)

        logging.info(
            'Loaded config version %s for component %s:%s',
            config_version,
            component_name,
            component_version)

        if not subtree:
            return config

        try:
            result = util.dict_subtree(config, subtree)
        except KeyError:
            raise exceptions.ConfigDoesNotExistException(
                'Subtree {} not found in config {}'.format(
                    subtree,
                    config))

        return result


    def _write_component_config(
            self,
            component_name,
            component_version,
            item,
            strict,
            **kwargs):
        """ Write the provided component config into the backend data store.

            :param component_name: the name of the component
            :type component_name: str
            :param component_version: the version of the component
            :type component_version: str
            :param item: the config to write
            :type item: dict
            :param strict: if true, then consider the provided item to be the
                exact value to store for the specified component.  If false,
                then treat this item as a patch to merge into any existing
                config.
            :type strict: bool

            :return nothing
            :rtype NoneType
        """
        latest_version = None
        if not strict:
            (latest_version, existing_config) = self._read_latest_config(
                component_name, component_version)

            # Really gross, but we built our initial config backend API with
            # the implicit assumption that nested structures would be flattened.
            # This dictated the necessary behavior for patching the new item
            # into the existing item when strict==False.  The easiest way to
            # do this with a natively-nested backend like this one is to
            # do the merge in flat-space.
            # This should eventually be replaced with a clearer API: for example,
            # allow the caller to provide a merge method rather than a boolean
            # for controlling this.
            flat_to_store = {} if not existing_config else \
                flatten_utils.flatten(existing_config, '/')
            flat_to_store.update(flatten_utils.flatten(item, '/'))

            to_store = flatten_utils.unflatten(flat_to_store, '/')

        else:
            existing_versions = self._list_config_versions(component_name, component_version)
            latest_version = max(existing_versions) if existing_versions else None
            to_store = item

        self._write_config(
            component_name,
            component_version,
            (latest_version or ConfigVersion(0)).increment(),
            to_store)

    def list_component_versions(
            self,
            component_name,
            **kwargs):
        """ List the available config versions for the named component

            :param component_name: the name of the component
            :type component_name: str

            :return the available versions
            :rtype frozenset<str>
        """
        return frozenset(
            self._list_dir(self.config_base_blob_name(component_name, None)))

    @retryable((GatewayTimeout, ServiceUnavailable), tries=5, delay=3, backoff=2, logger=logging)
    def delete_component_version(
            self,
            component_name,
            component_version,
            **kwargs):
        """ Delete the specified component

            :param component_name: the name of the component
            :type component_name: str
            :param component_version: the version of the component
            :type component_version: str

            :return nothing
            :rtype NoneType
        """
        blob_prefix = self.config_base_blob_name(component_name, component_version)
        for blob in self.bucket.list_blobs(prefix=blob_prefix):
            logging.info('Deleting file: %s', blob.name)
            blob.delete()
