from builtins import object
import abc

from stallion import util, constants
from stallion.config.manager import FINGERPRINT_CONFIG_NAME, FINGERPRINT_CONFIG_VERSION
from future.utils import with_metaclass

class ConfigBackendBase(with_metaclass(abc.ABCMeta, object)):
    @abc.abstractproperty
    def name(self):
        pass

    # Each config backend can optionally include a marshmallow schema that will
    # be used to validate its properties.  The validated properties will be
    # bound to the backend instance `properties` variable.
    properties_schema = None

    def __init__(self, properties):
        self.properties = self.validate_properties(properties or {})

    @classmethod
    def validate_properties(cls, properties):
        if not cls.properties_schema:
            if properties:
                raise ValueError(
                    'Config backend {} does not accept properties (found {})'.format(
                        cls.name,
                        properties))
            return properties
        else:
            loaded = cls.properties_schema.load(properties)
            if loaded.errors:
                raise ValueError(
                    'Error loading properties `{}` for config backend {}: {}'.format(
                        properties,
                        cls.name,
                        loaded.errors))
            return loaded.data

    @abc.abstractmethod
    def get_component_config(
            self,
            component_name,
            component_version,
            subtree=None):
        """ Retrieve the configuration for the specified component.

            :param component_name: the name of the component
            :type component_name: str
            :param component_version: the version of the component
            :type component_version: str
            :param subtree: if specified, then the config will be pruned to include
                only the specified subtree (represented as a list of keys)
            :type subtree: list<str>

            :return the component's configuration, in its fully nested form
            :rtype dict
        """
        pass

    @abc.abstractmethod
    def _write_component_config(
            self,
            component_name,
            component_version,
            item,
            strict,
            **kwargs):
        """ Write the provided component config into the backend data store.

            :param component_name: the name of the component
            :type component_name: str
            :param component_version: the version of the component
            :type component_version: str
            :param item: the config to write
            :type item: dict
            :param strict: if true, then consider the provided item to be the
                exact value to store for the specified component.  If false,
                then treat this item as a patch to merge into any existing
                config.
            :type strict: bool

            :return nothing
            :rtype NoneType
        """
        pass

    @abc.abstractmethod
    def list_component_versions(
            self,
            component_name,
            **kwargs):
        """ List the available config versions for the named component

            :param component_name: the name of the component
            :type component_name: str

            :return the available versions
            :rtype frozenset<str>
        """
        pass

    @abc.abstractmethod
    def delete_component_version(
            self,
            component_name,
            component_version,
            **kwargs):
        """ Delete the specified component

            :param component_name: the name of the component
            :type component_name: str
            :param component_version: the version of the component
            :type component_version: str

            :return nothing
            :rtype NoneType
        """
        pass

    def write_component_config(
            self,
            component_name,
            component_version,
            item,
            strict=False,
            **kwargs):
        self._validate_version(component_name, component_version)
        self._write_component_config(
                component_name,
                component_version,
                item,
                strict=strict,
                **kwargs)

    def _validate_version(self, component_name, component_version):
        if util.is_semver(component_version):
            return

        if component_name == FINGERPRINT_CONFIG_NAME and \
                component_version == FINGERPRINT_CONFIG_VERSION:
            return

        if component_version == constants.NO_CODE_VERSION:
            return

        raise ValueError('Invalid component version `{}` for `{}`: we '
            'only write semvers into the ConfigBackend!'.format(
                component_version,
                component_name))
