from builtins import str
from builtins import object
import traceback
import logging

from stallion.schemas.runtime_config import RuntimeConfigServiceSchema
from stallion.operations import OperationStatus
from stallion.exceptions import ConfigDoesNotExistException
from stallion import constants

FINGERPRINT_CONFIG_NAME = 'fingerprints'
FINGERPRINT_CONFIG_VERSION = 'current'

class ConfigManager(object):
    """
    Manages component configurations.

    :param default_config_backend: the default ConfigBackend to use; this will
        be used for any deployment state storage (e.g. fingerprints), and for
        any component configurations that are not overridde by the
        component_config_backends parameter.
    :type default_config_backend: ConfigBackendBase
    :param component_manager: a component manager instance
    :type component_manager: ComponentManager
    :param component_config_backends: config backends to use for each component;
        only necessary if some components do not use the default backend.
    :type component_config_backends: dict <string, ConfigBackendBase>
    """
    def __init__(
            self,
            project_id,
            default_config_backend,
            component_manager,
            component_config_backends=None):
        self.project_id = project_id
        self.default_config_backend = default_config_backend
        self.component_manager = component_manager
        self.component_config_backends = component_config_backends or {}

    @staticmethod
    def for_project(project, component_manager):
        """ Create a ConfigManager instance for the provided project
            configuration.

            :param project: the project configuration for which to create the
                ConfigManager
            :type project: stallion.Project
            :param component_manager: a component manager to use for this
                ConfigManager.
            :type component_manager: stallion.components.ComponentManager
        """
        from .backend import build_config_backend

        default_config_backend = build_config_backend(project.config_backend)

        component_config_backends = {}
        for component in list(project.components.values()):
            component_backend_conf = component.descriptor.get('config_backend')
            if not component_backend_conf:
                continue

            component_config_backends[component.name] = build_config_backend(
                component_backend_conf)

        return ConfigManager(
            project_id=project.id,
            default_config_backend=default_config_backend,
            component_manager=component_manager,
            component_config_backends=component_config_backends)

    def _get_config_backend(self, component_name):
        return self.component_config_backends.get(
            component_name,
            self.default_config_backend)

    def get_component(
            self,
            component_name,
            component_version,
            validate_config=True,
            decrypt_secrets=False,
            ignore_fields=None):
        component_version = component_version or constants.NO_CODE_VERSION
        variables = self._get_config_backend(component_name).get_component_config(
                component_name,
                component_version)

        if not variables:
            raise ConfigDoesNotExistException('Component configuration not found for {}:{}'.format(
                component_name,
                component_version))

        # Add some components to the descriptor that are encoded in the
        # variable names rather than as separate variables.
        descriptor = variables.get('descriptor').copy()
        descriptor['name'] = component_name
        descriptor['code_version'] = component_version

        return self.component_manager.get_component(
                descriptor = descriptor,
                config_dir = variables.get('config_dir'),
                config = variables.get('config'),
                validate_config = validate_config,
                decrypt_secrets = decrypt_secrets,
                ignore_fields = ignore_fields)


    def write_component_settings(self, component, dry_run):
        """ Write the contents of the component's settings to the RuntimeConfigurator
            service.  Note that this method does not check fingerprints to determine
            whether a write is necessary, nor does it update fingerprints once
            the write is complete, and nor does it run any config setup or
            push hooks.  The complete config push cycle is performed instead by
            the update_component() / update_components() methods.

            :param component: the component to push
            :type component: Component
            :param dry_run: whether this is a dry run.  If so, the config is not
                actually pushed, and a message is logged to indicate that.
            :type dry_run: bool
        """

        logging.info('Pushing component settings for %s', component)

        if dry_run:
            logging.info('  dry run: Not pushing config')
            return

        # Set strict=True because this component's config will be written to
        # component-specific and version-specific namespace
        self._get_config_backend(component.name).write_component_config(
                component.name,
                component.version,
                self._serialize_component(component),
                strict=True)


    def update_component(
                self,
                component,
                deployer,
                dry_run,
                deployed_fingerprints=None,
                force_config_push=False):
        """ Check the deployed configuration for the provided component, and
            push an update if required.  Pushes include both settings and any
            config push hooks assigned to the component.  This method runs all
            config setup hooks prior to checking the config status, and it runs
            all cleanup steps prior to returning.

            :param component: the component to update
            :type component: Component
            :param dry_run: whether to treat this as a dry-run, ie to skip any
                actual deployment steps
            :type dry_run: bool
            :param deployed_fingerprints: Deployed component fingerprints, if
                they have already been retrieved by the caller.  If not, this
                method will retrieve the necessary fingerprints itself (ie this
                is only used to avoid unnecssary requests from RuntimeConfig)
            :type deployed_fingerprints: dict
        """

        try:
            self._run_config_setup_hooks('setup', component, deployer, dry_run)

            if not self._config_update_required(
                    component=component,
                    force_config_push=force_config_push,
                    deployed_fingerprints=deployed_fingerprints):
                # no push needed.
                # status message was already logged inside _config_update_required()
                return OperationStatus.SKIPPED

            self.write_component_settings(component, dry_run)

            self._run_config_push_hooks(component, deployer, dry_run)

            self.write_fingerprint(component, deployer, dry_run, fingerprint_type='config')

        finally:
            self._run_config_setup_hooks('cleanup', component, deployer, dry_run)

        return OperationStatus.SUCCESS


    def update_components(self, components, deployer, dry_run, force_config_push=False):
        """ Conveniently loop through and update all components, while making
            just one request to get_fingerprints().
        """
        fingerprints = None if force_config_push else self.get_fingerprints()

        results = {}
        for component in components:
            try:
                results[component.name] = self.update_component(
                        component,
                        deployer,
                        dry_run,
                        deployed_fingerprints=fingerprints,
                        force_config_push=force_config_push)
            except Exception as e:
                logging.error("Component [%s] CONFIG failed to deploy", component)
                logging.error("Error message [%s]", e)
                logging.error(traceback.format_exc())
                results[component.name] = OperationStatus.ERROR

        return results


    def get_fingerprints(self, component = None, fingerprint_type = None):
        self._check_fingerprint_type(fingerprint_type)

        logging.debug('Processing get_fingerprints(%s, %s)',
                component.name if component else None, fingerprint_type)

        fingerprints = None
        try:
            subtree = [component.name if component else None, fingerprint_type]
            fingerprints = self.default_config_backend.get_component_config(
                    component_name=FINGERPRINT_CONFIG_NAME,
                    component_version=FINGERPRINT_CONFIG_VERSION,
                    subtree=list([_f for _f in subtree if _f]))
            logging.debug('Retrieved fingerprints: %s', str(fingerprints))
        except ConfigDoesNotExistException:
            logging.info('No fingerprints exist yet: must be an initial deploy?')

        return fingerprints or {}


    def _run_config_setup_hooks(self, mode, component, deployer, dry_run):
        if mode not in ['setup', 'cleanup']:
            raise ValueError('Invalid value `{}` for parameter `mode`: must '
                    'be one of {{`setup`, `cleanup`}}'.format(mode))

        if not component.config_setup_hooks:
            return

        # Run cleanup steps in opposite order to setup steps, as if we
        # pushed the steps onto a stack or whatever
        hooks = component.config_setup_hooks if mode == 'setup' else \
                reversed(component.config_setup_hooks)

        for hook in hooks:
            logging.info('Running config setup hook %s', hook)
            if mode == 'setup':
                hook.run(component, deployer, self, dry_run)
            else:
                hook.cleanup(component, deployer, self, dry_run)


    def _run_config_push_hooks(self, component, deployer, dry_run):
        if not component.config_push_hooks:
            return

        for hook in component.config_push_hooks:
            logging.info('Running config push hook %s', hook)
            hook.run(component, deployer, self, dry_run)


    def _config_update_required(
            self,
            component,
            deployed_fingerprints=None,
            force_config_push=False):

        def get_deployed_config_fingerprint():
            """ A little messy with all the various considerations, so put it
                in a method to restrict the scopes of these variables
            """
            all_fingerprints = deployed_fingerprints or self.get_fingerprints()

            component_fingerprints = all_fingerprints.get(component.name, {})

            # For legacy support (TODO: do we have any remaining legacy deployments?)
            # We have to check whether the deployed fingerprint was a string or
            # a dict.  But if it was a string, we must re-deploy, so set to None
            if not isinstance(component_fingerprints, dict):
                return None

            return component_fingerprints.get('config')

        if force_config_push:
            logging.info(
                    'Not checking fingerprints for component %s because '
                    'force_config_push is True; this will trigger a '
                    'config push.',
                    component)
            return True

        local_config_fingerprint = component.get_config_fingerprint()
        deployed_config_fingerprint = get_deployed_config_fingerprint()

        if deployed_config_fingerprint == local_config_fingerprint:
            logging.info(
                    'Component %s config fingerprint %s is unchanged, skipping config push',
                    component,
                    local_config_fingerprint)

            return False

        logging.info('Component %s fingerprint %s does not match deployed '
                'fingerprint %s: config update required',
                    component,
                    local_config_fingerprint,
                    deployed_config_fingerprint)

        return True


    def write_fingerprint(self, component, deployer, dry_run, fingerprint_type=None):
        self._check_fingerprint_type(fingerprint_type)

        to_write = { component.name: {} }

        if fingerprint_type == 'config' or not fingerprint_type:
            to_write[component.name]['config'] = component.get_config_fingerprint()

        if fingerprint_type == 'deploy' or not fingerprint_type:
            to_write[component.name]['deploy'] = component.get_deploy_fingerprint(deployer)


        if dry_run:
            logging.info('  dry run: not pushing fingerprint (%s) for %s',
                    to_write[component.name],
                    component)
            return

        logging.info('Writing fingerprints for `%s`: %s',
                     component.name,
                     to_write[component.name])

        # Set strict=False because all the fingerprints share a variable
        # namespace and we don't want to delete all of the ones that do not
        # match this component (nor do we want to delete deploy fingerprints when
        # pushing config fingerprints, or vice-versa
        self.default_config_backend.write_component_config(
                component_name=FINGERPRINT_CONFIG_NAME,
                component_version=FINGERPRINT_CONFIG_VERSION,
                item=to_write,
                strict=False)


    def _check_fingerprint_type(self, fingerprint_type):
        """ A shared method for enforcing the appropriate values for any
            fingerprint_type arguments.  Helps ensure consistency between values.
        """
        if fingerprint_type not in ['config', 'deploy', None]:
            raise ValueError('Invalid fingerprint_type: {} (allowed values are: config, deploy)'.format(
                fingerprint_type))


    def delete_inactive_versions(self, component_name, active_versions, dry_run):
        """ Delete inactive versions by listing the set of versions currently
            stored in the backend, and removing any that are not present in the
            provided list of active versions.

            As a safety mechanism, this method will refuse to delete any config
            versions if it fails to find all of the active versions provided.  This
            ensures that no active-version config is accidentally deleted due to
            a mismatch in the version naming between the deployer and the config
            backend.

            Note that in checking active versions, we do a case-insensitive
            comparison between version strings, which has almost no impact except
            in the cases of prerelease deployments, which may contain prerelease
            strings of various capitalization states. The deployers generally
            (though not necessarily always) disregard the casing of the prerelease
            strings when components are deployed, which means that the list of
            active config versions cannot be pulled back with complete fidelity,
            and we can enter situations in which the deleter logic gets stuck,
            refusing to delete anything because it cannot find the current
            active config due to case mismatch.

            :param component_name: the name of the component
            :type component_name: str
            :param active_versions: list of actively deployed versions of this component
            :type active_versions: list<str>
            :param dry_run: whether this is a dry run, i.e. the delete should not
                actually be pushed into the config backend
            :type dry_run: bool
        """

        active_versions = frozenset([v.lower() for v in active_versions])
        component_config_backend = self._get_config_backend(component_name)
        existing_versions = component_config_backend.list_component_versions(component_name)
        existing_versions_lowercased = frozenset([v.lower() for v in existing_versions])

        # It is helpful to first check whether there would be anything to delete,
        # if we proceeded, before doing the safety check for actively deployed
        # services.  This prevents erroring-out when there are active deployments
        # that did not deploy to the config backend for some reason (e.g. some
        # deployments do not use the config backend at all)
        if existing_versions_lowercased.issubset(active_versions):
            logging.info('No config deployments found for inactive versions of '
                         'component `%s`.  Nothing to delete.',
                         component_name)
            return


        if not active_versions.issubset(existing_versions_lowercased):
            # Out of paranoia, we check to make sure that the active versions
            # we are provided are actually present, so that we will not delete
            # them.  This gives us robustness to any errors in the code that
            # may cause version strings not to match between deployers and
            # config manager, and makes sure we don't accidentally delete all
            # deployed configs.
            raise Exception(
                    'Some active config versions not found for component {}: {} (all versions found: {})'.format(
                        component_name,
                        ', '.join(active_versions - existing_versions_lowercased),
                        ', '.join(existing_versions_lowercased)))


        delete_versions = [ version for version in existing_versions
                if version.lower() not in active_versions ]

        for version in delete_versions:
            if dry_run:
                logging.info('DRY RUN: Not deleting inactive config %s:%s',
                             component_name,
                             version)
                continue

            logging.info(
                'Deleting inactive config %s:%s',
                component_name,
                version)

            component_config_backend.delete_component_version(
                component_name,
                version)

    @classmethod
    def _serialize_component(cls, component):
        loaded = RuntimeConfigServiceSchema().dump(component._asdict())

        if loaded.errors:
            raise Exception('Errors packaging component config for RuntimeConfig service: {}'.format(
                loaded.errors))

        return loaded.data
