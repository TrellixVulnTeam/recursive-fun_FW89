from builtins import zip
from builtins import range
from builtins import object
from operator import itemgetter
import base64
import re
import six

# The utilities in this module are transforming between nested dictionary
# objects and flat structures required by the GCP runtime config
# service (and by other databases that we might imagine using).

# For example, the object
# {
#   'item': {
#       key1: 10,
#       key2: "test",
#       key3: {
#           key3a: 20,
#           key3b: True,
#       }
#     }
# }
#
# will be flattened to:
# {
#   item/key: 10,
#   item/key2: test
#   item/key3/key3a: 20
#   item/key3/key3b: True
# }
# which can likewise be unflattened back to the original nested structure.

# We flatten lists by encoding their indices in the key paths using a
# distinctive string pattern.
# We must use a pattern that is permitted by the runtime config
# service (ie characters like [] are not permitted, so we can't use them
# to indicate list indexes).
LIST_INDEX_PATTERN = 'L--(\d+)'

# We also reserve key patterns to indicate empty lists and dicts
EMPTY_LIST_INDICATOR = 'L--X'
EMPTY_DICT_INDICATOR = 'D--X'

# For example, the object
# {
#   'item': {
#       key1: 10,
#       key2: [ 20, 30 ],
#       key3: [],
#       key4: {},
#     }
# }
#
# will get flattened to:
# {
#   item/key: 10,
#   item/key2/L--0: 20,
#   item/key2/L--1: 30,
#   item/key3/L---: None,
#   item/key4/D---: None,
# }

RESERVED_KEYS = frozenset([EMPTY_LIST_INDICATOR, EMPTY_DICT_INDICATOR])

def encode_list_index(idx):
    return 'L--%d' % idx

# Unflattening in the presence of lists is a bit tricky, but it's easier if we
# first push all of the keys into a tree structure.
class Node(object):
    """ We use a tree structure for unflattening an array of separator-delimited
        keys into a dictionary
    """
    def __init__(self, path_key, value = None):
        self.path_key = path_key
        self.value = value
        self.children = {}

    def _get_key(self):
        if self.path_key is None:
            return None

        m = re.match(LIST_INDEX_PATTERN, self.path_key)
        return int(m.group(1)) if m else self.path_key

    def _is_empty_list(self, child_trees):
        if all( key != EMPTY_LIST_INDICATOR for (key, value) in child_trees ):
            return False

        assert len(child_trees) == 1, \
                'Invalid empty-list specification among child trees {}'.format(child_trees)

        assert child_trees[0][1] == None or child_trees[0][1] == 'None', \
                'Invalid child contents in empty-list node `{}`'.format(child_trees[0])

        return True

    def _is_list(self, child_trees):
        if all( not isinstance(key, int) for (key, value) in child_trees ):
            return False

        assert all( isinstance(key, int) for (key, value) in child_trees ), \
                'Invalid node `{}`: cannot mix list and dict child types `{}`'.format(
                        self, self.children)

        return True

    def _is_empty_dict(self, child_trees):
        if all( key != EMPTY_DICT_INDICATOR for (key, value) in child_trees ):
            return False

        assert len(child_trees) == 1, \
                'Invalid empty-dict specification among child trees {}'.format(child_trees)

        assert child_trees[0][1] == None or child_trees[0][1] == 'None', \
                'Invalid child contents in empty-dict node `{}`'.format(child_trees[0])

        return True

    def build(self):
        if not self.children:
            return (self._get_key(), self.value)

        child_trees = [ c.build() for c in list(self.children.values()) ]

        value = None
        if self._is_empty_list(child_trees):
            value = []

        elif self._is_empty_dict(child_trees):
            value = {}

        elif self._is_list(child_trees):
            (keys, value) = list(zip(*sorted(child_trees, key = itemgetter(0))))

            assert list(keys) == list(range(len(keys))), \
                    'Error: Non-consecutive array indexes found: {}'.format(child_trees)

            value = list(value)
        else:
            value = dict(child_trees)

        return (self._get_key(), value)

    def insert(self, path, value):
        if len(path) == 1:
            assert path[0] not in self.children
            self.children[path[0]] = Node(path[0], value)
            return

        self.children.setdefault(path[0], Node(path[0]))

        self.children[path[0]].insert(path[1:], value)

def unflatten(items, sep):
    tree = Node(None)
    for (item_name, value) in six.iteritems(items):
        path = item_name.split('/')

        tree.insert(path, value)

    return tree.build()[1]

def flatten(item, sep):
    def _doit(current_path, item, results):
        if isinstance(item, list) and item:
            for (idx, value) in enumerate(item):
                _doit(current_path + [ encode_list_index(idx) ], value, results)

        elif isinstance(item, list):
            results.append((sep.join(current_path + [ EMPTY_LIST_INDICATOR ]), None))

        elif isinstance(item, dict) and item:
            for (key, value) in six.iteritems(item):
                assert key not in RESERVED_KEYS and not re.match(LIST_INDEX_PATTERN, key), \
                        'Invalid key path `{}`: may not used reserved keys `{}`'.format(
                                current_path, RESERVED_KEYS | set([ LIST_INDEX_PATTERN ]))

                _doit(current_path + [ key ], value, results)

        elif isinstance(item, dict):
            results.append((sep.join(current_path + [ EMPTY_DICT_INDICATOR ]), None))

        else:
            results.append((sep.join(current_path), item))

    result = []
    _doit([], item, result)

    return dict(result)
