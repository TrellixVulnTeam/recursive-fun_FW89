#!/usr/bin/env python3
from builtins import str
from builtins import object
import os
import json
import subprocess
import logging
import traceback
import semver
from stallion.deploy import git
from stallion import exceptions


class ReleaseProcessor(object):
    def __init__(self, args):
        self.artifact_name = args.artifact_name
        self.next_git_tag_version = args.next_git_tag_version
        self.version_file = args.version_file

        self.release_version = self.get_release_version(
                self.version_file,
                self.next_git_tag_version)

        self.git_tag_name = self.artifact_name + '@' + self.release_version

        self.git_url = args.git_url or os.getenv('GIT_URL')
        self.git_branch = args.git_branch or os.getenv('GIT_BRANCH')
        assert self.git_branch.startswith('origin/'), \
                'Invalid git_branch {}: expected something of the format origin/.*'.format(
                        self.git_branch)

        self.remote_branch = self.git_branch[len('origin/'):]

        self.temp_git_branch_prefix = args.temp_git_branch_prefix
        self.temporary_branch = self.build_temporary_branch()

        self.username = self.password = None
        if args.jenkins_git_creds_name:
            assert not args.git_username and not args.git_password, \
                    'Do not supply a git-username and/or git-password when jenkins-git-creds is set!'

            self.username = os.environ[args.jenkins_git_creds_name + '_USR']
            self.password = os.environ[args.jenkins_git_creds_name + '_PSW']
        elif args.git_username or args.git_password:
            assert args.git_username and args.git_password, \
                    'Must supply both or none of git-username/git-password'

            self.username = args.git_username
            self.password = args.git_password

        self.authed_git_remote = self.build_authed_git_remote(
                self.username,
                self.password,
                self.git_url)

        self.user_email = args.git_user_email
        self.user_display_name = args.git_user_display_name

        self.dry_run: bool = args.dry_run
        self.error_on_failure: bool = args.error_on_failure


    @classmethod
    def get_release_version(cls, version_file, next_git_tag_version):
        file_version = cls.read_version_file(version_file)
        if not file_version:
            return next_git_tag_version

        finalized_file_version = semver.finalize_version(file_version)
        result = semver.max_ver(finalized_file_version,
                                next_git_tag_version)

        logging.info(
                'Release version is %s (max of git-version `%s` and '
                'file-version `%s`)',
                result,
                next_git_tag_version,
                finalized_file_version)

        return result


    @staticmethod
    def read_version_file(version_file):
        if not os.path.isfile(version_file):
            logging.debug('%s does not exist, no version to read',
                          version_file)
            return None

        version = None
        with open(version_file) as _in:
            version = json.load(_in).get('version')

        logging.debug('Read version %s from file %s',
                      version,
                      version_file)

        return version

    @classmethod
    def write_version_file(
            cls,
            version_file,
            release_version,
            bump_and_set_dev=False):
        version = cls._get_version(release_version, bump_and_set_dev)

        file_content = json.dumps({'version': version})

        logging.info('Writing content `%s` to file `%s`',
            file_content,
            os.path.abspath(version_file))

        with open(version_file, 'w') as _out:
            _out.write(file_content + '\n')

        return version


    @classmethod
    def _get_version(cls, release_version, bump_and_set_dev):
        if not bump_and_set_dev:
            return release_version

        bumped = semver.bump_patch(release_version)
        return semver.bump_prerelease(bumped, token='dev')

    def do_release(self):
        self._switch_to_temporary_branch()

        try:
            self.write_version_file(self.version_file, self.release_version)

            self._commit_and_tag_release()

            self._pull_upstream_changes()

            dev_version = self.write_version_file(
                    self.version_file,
                    self.release_version,
                    bump_and_set_dev=True)

            self._commit_dev_version(dev_version)

            self._push()
        except Exception as e:
            logging.error("An error occurred: {}".format(e))
            logging.error(traceback.format_exc())

            logging.error("Deleting git tag `{}`".format(self.git_tag_name))
            self.git_failsafe('tag', '-d', self.git_tag_name)

            if self.error_on_failure:
                raise e
        finally:
            # Clean up by deleting the temporary branch.
            logging.info('Cleanup: deleting temporary branch %s',
                         self.temporary_branch)

            # We must first detach from the branch, otherwise we won't be
            # able to delete it.  checkout HEAD^ works for that.
            self.git('checkout', 'HEAD^')
            self._delete_temporary_branch()

    @staticmethod
    def build_authed_git_remote(username, password, git_url):
        import uritools

        if not username:
            return git_url

        split = uritools.urisplit(git_url)

        authed_host = '{username}:{password}@{host}'.format(
                username = username,
                password = password,
                host = split.authority)

        return split._replace(authority=authed_host).geturi()


    def build_temporary_branch(self):
        return '-'.join([_f for _f in [
            self.temp_git_branch_prefix,
            self.artifact_name,
            self.release_version] if _f])


    def _base_git_args(self):
        result = ['git']
        if self.user_email:
            result += ['-c', 'user.email="{}"'.format(self.user_email)]

        if self.user_display_name:
            result += ['-c', 'user.name="{}"'.format(self.user_display_name)]

        return result


    def git(self, *args):
        args = self._base_git_args() + list(args)

        # Filter out None from `args` to avoid an exception, but warn if we did that since
        # it's noteable
        logging.debug('Executing: `%s`', ' '.join(arg for arg in args if arg))
        if None in args:
            logging.debug('Argument list above contained at least one None')

        return subprocess.check_output(args).decode('utf-8')


    def git_failsafe(self, *args):
        result = None
        try:
            result = self.git(*args)
        except Exception as e:
            logging.info('Command did not succeed, but that is not an error: %s', str(e))

        return result


    def _delete_temporary_branch(self):
        self.git_failsafe('branch', '-D', self.temporary_branch)

    def _switch_to_temporary_branch(self):
        # Jenkins starts out in headless mode, so we create a new
        # git-branch that tracks the upstream master.  We make our
        # first commit and then pull the upstream; next we set
        # the new version and push the temp branch to the remote
        # master branch.

        logging.info("Creating temporary git-branch %s", self.temporary_branch)

        # delete the temp branch name, if it already exists from a prior
        # failed build

        self._delete_temporary_branch()

        self.git('checkout', '-b', self.temporary_branch)


    def _commit_and_tag_release(self):
        logging.info("Committing artifact version")
        self.git('commit', '-a', '-m',
                    'Set {} version to {} [ci-skip]'.format(
                       self.artifact_name,
                       self.release_version))

        self.git_failsafe('tag', '-d', self.git_tag_name)
        self.git('tag', '-a', self.git_tag_name, '-m',
                    "Tagging commit for container version {}".format(
                        self.release_version))


    def _pull_upstream_changes(self):
        self.git('pull', '--no-edit', 'origin', self.remote_branch)


    def _commit_dev_version(self, dev_version):
        logging.info('Set development version to %s', dev_version)
        self.git('commit', '-a', '-m',
                    'Back to development: {} [ci-skip]'.format(dev_version))


    def _push(self):
        if self.dry_run:
            logging.info('DRY RUN: not pushing any local commits')
            return

        logging.info("Pushing local commits to remote branch %s", self.remote_branch)
        self.git('push', self.authed_git_remote, self.temporary_branch + ':' + self.remote_branch)

        logging.info("Pushing local tag")
        self.git('push', self.authed_git_remote, self.git_tag_name)

    @classmethod
    def bump_version(cls, current_version, increment=False, increment_major=False, exception=None):
        # Returns the version based on the increment flag specified (or current version if neither paramater is set to True)
        if increment and increment_major:
            raise Exception('Parameters increment and increment_major cannot be true together. Either the patch or the major can be incremented, but not both at the same time')
        if current_version == '0.0.0' and not (increment or increment_major):
            raise exception
        if increment:
            return semver.bump_patch(current_version)
        elif increment_major:
            return semver.bump_major(current_version)

        return current_version

    @classmethod
    def get_git_tag_version(
            cls,
            code_repo_owner,
            code_repo,
            tag_name,
            tag_separator,
            major_version=None,
            use_local_history=False):

        try:
            current_version = git.get_latest_version(
                    code_repo_owner,
                    code_repo,
                    tag_name,
                    tag_separator,
                    major_version,
                    use_local_history=use_local_history)
            logging.debug('latest version for tag name %s: %s', tag_name, current_version)
        except exceptions.MissingVersionException as e:
            logging.info('No versions yet deployed for tag name %s', tag_name)
            return '0.0.0', e

        return current_version, None
