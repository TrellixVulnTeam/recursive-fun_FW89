from builtins import object
import yaml
import logging
import os
import traceback
import six
from stallion.project import Project
from stallion.schemas.service_descriptor import ServiceDescriptorDeploySchema
from stallion.schemas.project import ProjectConfigSchema
from stallion.components.manager import ComponentManager

from stallion import components, deploy, constants, exceptions, util

class ConfigFileLoader(object):
    SETTINGS_FILENAME = 'settings.yaml'

    @property
    def errors(self):
        result = {}
        if self.failed_projects:
            result['failed_projects'] = self.failed_projects

        for (project_id, project) in six.iteritems(self.projects):
            if project.errors:
                result[project_id] = project.errors

        return result

    def __init__(self, conf_path, projects = None):
        super(ConfigFileLoader, self).__init__()
        self.component_manager = ComponentManager()
        self.conf_path = conf_path
        (self.projects, self.failed_projects) = self.load_projects(only_projects = projects)

    def get_component(self, project_id, component_name, component_version):
        # For file loader, we cannot specify a component version because the
        # files are always stored as their latest version
        assert component_version is None or component_version == constants.LATEST, \
                'Invalid component_version {} for {}'.format(
                        component_version,
                        self.__class__.__name__)

        project = self.get_project(project_id)

        result = project.components.get(component_name)

        if not result:
            raise KeyError('Component `{}` is not defined in config path `{}`'.format(
                component_name, self.conf_path))

        return result

    def get_project(self, project_id):
        if project_id not in self.projects:
            raise KeyError('Project `{}` is not defined in config path `{}`'.format(
                project_id, self.conf_path))

        return self.projects[project_id]

    def render_service_config(self, config_path):
        from stallion import template
        if not os.path.exists(config_path):
            logging.warning('Component settings file not found at path %s',
                config_path)
            return None

        rendered_config = template.render_config_file(config_path)
        logging.debug('Rendered config file %s to: %s',
                      config_path,
                      rendered_config)

        return yaml.safe_load(rendered_config)

    def load_service_config(self, project_path, descriptor):
        config_dir = os.path.join(
                self.conf_path,
                project_path,
                descriptor['path'],
                )

        config_path = os.path.join(config_dir, self.SETTINGS_FILENAME)

        result = None
        try:
            conf = self.render_service_config(config_path)
            result = self.component_manager.get_component(
                    descriptor = descriptor,
                    config_dir = config_dir,
                    config = conf)

            # And now run any deployment-type-specific validation
            deployer = deploy.deployers.get_deployer_cls(result.descriptor['deployment_type'])
            deployer.validate_component(result)
        except Exception as e:
            # re-raise, but with added info to help tracking down to the
            # file containing the error
            raise Exception('Error in file {}: {}'.format(
                config_path,
                traceback.format_exc()))

        return result

    def validate_project(self, project, project_config_path):
        loaded = ProjectConfigSchema().load(project)

        if loaded.errors:
            raise Exception('Invalid project configuration in file `{}`: `{}`'.format(
                project_config_path,
                loaded.errors))

        return loaded.data

    @staticmethod
    def ensure_all_directories_used(config_dir, components):
        # Check whether there are extra dirs that are present in the project's
        # directory hierarchy but not used by the configuration.  This might
        # happen, for instance, if someone tries to add a new service but
        # forgets to add the service descriptor to the project's settings
        # file.  This check will help them out...
        dirs_used = [ c.config_dir for c in list(components.values()) ]

        util.ensure_no_dupes(
                list(components.values()),
                lambda component: component.config_dir,
                'Config dirs are referenced by multiple services',
                exceptions.SharedConfigDirException)

        dirs_present = frozenset(util.get_leaf_dirs(config_dir))

        # However we should not reject any leaf dirs that are subdirs of any
        # config dirs that we are using.
        unused_dirs = [ d for d in dirs_present
                if all(not d.startswith(p) for p in dirs_used) ]

        if unused_dirs:
            raise exceptions.UnusedConfigDirException(
                    'Unused directories present in path {}: {}'.format(
                        config_dir,
                        unused_dirs))

    def load_project_from_path(self, project_path):
        config_dir = os.path.join(self.conf_path, project_path)
        project_config_path = os.path.join(config_dir, self.SETTINGS_FILENAME)
        if not os.path.exists(project_config_path):
            raise Exception('Project settings file not found at path {}'.format(
                project_config_path))

        conf = None
        with open(project_config_path) as _in:
            conf = self.validate_project(yaml.safe_load(_in), project_config_path)

        components = {}
        errors = {}
        for (idx, service) in enumerate(conf['services']):
            if service.get('disabled'):
                logging.info('Skipping disabled service: %s', service['name'])
                continue

            try:
                components[service['name']] = self.load_service_config(
                    project_path = project_path,
                    descriptor = service)
            except Exception as e:
                service_name = service.get('name', 'item-%d' % idx)
                errors[service['name']] = e
                logging.error(
                        "Component [services.%s] in project [%s] failed to load. SKIPPING IT!",
                        service['name'],
                        conf['id'])
                logging.error("Error message [%s]", e)
                logging.error(traceback.format_exc())


        for (idx, config) in enumerate(conf['configurations']):
            try:
                components[config['name']] = self.load_service_config(
                        project_path = project_path,
                        descriptor = config)
            except Exception as e:
                config_name = config.get('name', 'item-%d' % idx)
                errors[config_name] = e
                logging.error(
                        "Component [configurations.%s] in project [%s] failed to load. SKIPPING IT!",
                        config_name,
                        conf['id'])
                logging.error("Error message [%s]", e)
                logging.error(traceback.format_exc())


        try:
            self.ensure_all_directories_used(config_dir, components)
        except Exception as e:
            errors['unused_directories'] = e

        return Project(
            id=conf['id'],
            config_backend=conf.get('config_backend'),
            components=components,
            errors=errors)

    def load_projects(self, only_projects = None):
        only_projects = frozenset(only_projects or [])

        settings_path = os.path.join(self.conf_path, self.SETTINGS_FILENAME)
        if not os.path.exists(settings_path):
            raise Exception('Project settings file not found at path {}'.format(
                settings_path))

        conf = None
        with open(settings_path) as _in:
            conf = yaml.safe_load(_in)

        projects = {}
        errors = {}
        for project in conf['project_paths']:
            if only_projects and project not in only_projects:
                logging.info('Skipping project %s', project)
                continue

            try:
                loaded_project = self.load_project_from_path(project)
                projects[loaded_project.id] = loaded_project
            except Exception as e:
                errors[project] = e
                logging.error("Project [%s] failed to load. SKIPPING IT!", project)
                logging.error("Error message [%s]", e)
                logging.error(traceback.format_exc())

        return (projects, errors)
