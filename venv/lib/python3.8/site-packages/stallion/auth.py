from builtins import object
import os
import time
import logging
import requests
import google.auth
from google.auth.transport.requests import Request
from google.oauth2 import id_token, service_account
from stallion import retry, exceptions

class Authorizer(object):
    @staticmethod
    def read_only():
        return Authorizer(scopes=['https://www.googleapis.com/auth/cloud-platform.read-only'])

    @staticmethod
    def read_write():
        return Authorizer(scopes=['https://www.googleapis.com/auth/cloud-platform'])
    def __init__(self, scopes = None):
        # default to the auth scopes needed for stallion, which are pretty
        # limited overall

        self.scopes = scopes
        self.service_account_file = os.getenv('GOOGLE_APPLICATION_CREDENTIALS')
        if self.service_account_file:
            logging.debug(
                    'Authorizer is using service account key file `%s`',
                    self.service_account_file)
        else:
            logging.debug('Authorizer is not using a service account key file')

        self.in_gce = self._check_gce()
        if self.in_gce:
            logging.debug('Authorizer is running in GCE')
        else:
            logging.debug('Authorizer is not running in GCE')

        self._creds = None
        self.id_tokens = {} # tokens will be a dict of audience: token

    @staticmethod
    def _check_gce():
        from stallion.client.runtimes import ComputeEngine
        return ComputeEngine.get_from_metadata('project/project-id') is not None

    def _get_creds(self):
        def _get_updated_creds():
            if not self._creds:
                (self._creds, _) = google.auth.default(scopes=self.scopes)

            if not self._creds.token or self._creds.expired:
                self._creds.refresh(Request())

            return self._creds

        retry.do_with_retry(
                lambda: _get_updated_creds(),
                max_attempts=3,
                base_sleep_time_sec=1,
                pass_exceptions = [ Exception ])

        return self._creds


    def _get_id_token_from_service_account(self, audience):
        credentials = service_account.IDTokenCredentials.from_service_account_file(
                self.service_account_file,
                target_audience=audience)

        retry.do_with_retry(
                lambda: credentials.refresh(Request()),
                max_attempts=3,
                base_sleep_time_sec=1,
                pass_exceptions = [ Exception ])

        return credentials.token


    def _get_id_token_from_metadata(self, audience):
        response = retry.requests_retry_session().get(
                'http://metadata/computeMetadata/v1/instance/service-accounts/default/identity',
                headers={'Metadata-Flavor': 'Google'},
                params={'audience': audience},
                timeout=10)

        if response.status_code != 200:
            raise Exception(
                    'Failed to retrieve id token! Code is {}, content is {}'.format(
                        response.status_code,
                        response.content))

        return response.content


    @staticmethod
    def _get_expiry(token):
        # return expiry time minus 5 minutes
        claims = id_token.verify_oauth2_token(token, Request())

        return claims.get('exp') - 5*60


    def get_id_token(self, audience):
        current_time = int(time.time())

        (token, expiry_time) = self.id_tokens.get(audience, (None, None))

        if token and current_time < expiry_time:
            return token

        if self.service_account_file:
            token = self._get_id_token_from_service_account(audience)
        elif self.in_gce:
            token = self._get_id_token_from_metadata(audience)
        else:
            if audience:
                logging.warn('Retrieving id token using application-default '
                             'credentials; ignoring the provided audience `%s`',
                             audience)
            token = self._get_creds().id_token

        self.id_tokens[audience] = (token, self._get_expiry(token))
        return token


    def get_access_token(self):
        return self._get_creds().token


    def get_access_session(self):
        session = retry.requests_retry_session()
        session.headers['Authorization'] = 'Bearer ' + self.get_access_token()

        return session


    def get_id_session(self, audience):
        session = retry.requests_retry_session()
        token = self.get_id_token(audience)
        if isinstance(token, bytes):
            token = token.decode('utf-8')

        session.headers['Authorization'] = \
                'Bearer ' + token

        return session


# Create a static authorizer object for reuse by the stallion tool set.
# Other libraries will probably need to use their own authorizer classes,
# because this one will only work for the scopes needed by stallion
authorizer = Authorizer(scopes=[
            'https://www.googleapis.com/auth/cloudruntimeconfig',
            'https://www.googleapis.com/auth/cloudkms'])
