from builtins import object
import os
import abc
import json
import hashlib
import logging
import semver
from stallion import exceptions, constants, util
from stallion.schemas.base import StrictSchema
from future.utils import with_metaclass

class BaseConfigPushHook(with_metaclass(abc.ABCMeta, object)):
    """ A config push hook is something that will run whenever the config
        needs to be pushed: either when a service is newly deployed, or when
        the local config fingerprint does not match the previously-deployed
        config fingerprint.  This is useful for deploying any configuration
        that is not captured in the component's settings.yaml file:
        for example, files that must be uploaded to the deployed service.
    """

    @abc.abstractmethod
    def run(component, deployer, config_manager, dry_run):
        pass


class BaseConfigSetupHook(with_metaclass(abc.ABCMeta, BaseConfigPushHook)):
    """ A config setup hook is something that will run when setting up the config
        for the component.  It will also run prior to any config push hooks,
        and its purpose is to prepare any information that may be required by
        those hooks require any information (e.g. pulling content out of a
        database or downloading files from a web URI).

        Most importantly, the config setup hook will run prior to computing
        config fingerprints, so that the computed fingerprints will reflect
        any state that is created by the setup hook.  This allows us to
        determine whether a config push is required due to some state change
        external to the Stallion configs.  As an example:
            Our Airflow components dynamically translate Oozie workflows from
            the BigData repo into yaml files that we load into Airflow via
            boundary-layer.  If one of those workflows were to change in
            BigData, we would need a way to determine this within Stallion
            so that we can update the deployed config appropriately.  The
            standard config push hooks cannot do this, because they only run
            once we already know that a config push is needed.  So this is where
            the config setup hook comes in.

        The hook must provide a cleanup() method to delete whatever it created
        in the run() step.
    """

    @abc.abstractmethod
    def cleanup(component, deployer, config_manager, dry_run):
        pass


class BaseComponent(with_metaclass(abc.ABCMeta, object)):
    @abc.abstractproperty
    def type():
        pass

    @abc.abstractproperty
    def schema():
        pass

    @abc.abstractproperty
    def allowed_deployment_types():
        pass

    config_setup_hooks = []
    config_push_hooks = []

    has_code_version = False # derived classes should set to True if they have code versions

    settings_schema_cls = None # users can provide configs that specify component-specific settings

    @property
    def version(self):
        return self.code_version if self.has_code_version else constants.NO_CODE_VERSION

    def __init__(
            self,
            descriptor,
            config_dir,
            config,
            validate_config=True,
            decrypt_secrets=False,
            ignore_fields=None):

        if not self.allowed_deployment_types or not \
                isinstance(self.allowed_deployment_types, frozenset):
            raise Exception('Invalid setting `allowed_deployment_types` for '
                    'component {} (expected a frozenset, found {})'.format(
                        self.__class__,
                        self.allowed_deployment_types))

        self.settings = self._validate_component_settings(descriptor.get('component_settings'))

        # Check the config hooks to make sure they have the proper type.
        # this could in principle be done in unit testing instead of runtime
        # testing, because it checks the code itself, not the configs.
        self._check_hooks(
                self.config_setup_hooks,
                'config_setup_hooks',
                BaseConfigSetupHook)

        self._check_hooks(
                self.config_push_hooks,
                'config_push_hooks',
                BaseConfigPushHook)

        self.descriptor = self._validate_descriptor(descriptor)
        self.config_dir = config_dir
        self.ignore_fields = ignore_fields or []

        if not isinstance(self.ignore_fields, list):
            raise ValueError(
                    'Invalid parameter ignore_fields: found `{}`, expected '
                    'a list<string>'.format(self.ignore_fields))

        # If validate_config is set to false, then don't call the validator
        # method.  This is most useful for building-in some flexibility for
        # schema definitions that co-occur in services.  For example, the auth
        # config schema appears alongside every other schema here, because of
        # our use of the etsy-auth-proxy base image for our services.  But now
        # if we change the schema for one service (e.g. airflow), then when the
        # auth service pulls in the config, if it tries to validate the entire
        # config then it will fail unless we deploy a new etsy-auth-proxy
        # in addition to a new airflow.  So for a case like that, we allow
        # the config validation to be disabled, with the presumption that
        # any necessary validation is done somewhere downstream.
        if decrypt_secrets and not validate_config:
            raise Exception('Invalid arguments: validate_config must be set '
                    'to True when decrypt_secrets is True')

        if self.ignore_fields and not validate_config:
            logging.warn(
                    'Ignoring parameter ignore_fields (== %s) because '
                    'validate_config is True',
                    self.ignore_fields)

        self.config = config if not validate_config else \
                self._validate_config(config, decrypt_secrets)

    @classmethod
    def _validate_component_settings(cls, settings):
        if not settings and not cls.settings_schema_cls:
            return

        if not cls.settings_schema_cls:
            raise Exception(
                'Component type `{}` does not accept component_settings, but received {}'.format(
                    cls.type,
                    settings))

        loaded = cls.settings_schema_cls().load(settings or {})
        if loaded.errors:
            raise Exception(
                'Invalid settings for component type `{}`: {}'.format(
                    cls.type,
                    loaded.errors))

        return loaded.data

    @staticmethod
    def _check_hooks(hooks, hook_name, expected_cls):
        bad_hooks = [ hook
                for hook in hooks if not isinstance(hook, expected_cls) ]
        if bad_hooks:
            raise Exception('Internal error: bad {}: {} (not subclasses of {}!)'.format(
                hook_name,
                bad_hooks,
                expected_cls))

    @property
    def name(self):
        return self.descriptor['name']


    def get_config_fingerprint(self):
        """ Fingerprint the configuration for this service.  The fingerprint is
            just a md5 of:
              - the service configuration, loaded into a dictionary, with any
                defaults or other deserialization transformations applied
              - the service descriptor (ie the entry in the project-level
                settings.yaml file corresponding to this component)
              - the raw file contents of this component's config dir.
              - the path to the settings.yaml file for this service; the content
                of this variable is redundant with the config dir content (ie
                any changes to it will be detected in that) but we include it
                because it's nice to be able to use the self._asdict() serializer method

            This should be used by CI/CD to help determine whether any configs have
            changed and need to be pushed.
        """
        digest = hashlib.md5()
        config_str = json.dumps(self._asdict(), sort_keys = True)
        digest.update(config_str.encode('utf-8'))

        if not os.path.isdir(self.config_dir):
            logging.warning('Configuration directory not found at path %s: '
                'If this deployment depends on any configuration files, '
                'stallion will not be able to track changes to those files!',
                self.config_dir)

            result = digest.hexdigest()
        else:
            (result, _) = util.fingerprint(self.config_dir, digest=digest)

        return result


    @classmethod
    def _validate_descriptor(cls, descriptor):
        # Make sure the type is correct, and also that name and code_version
        # are present.
        # The latter two checks are needed as a means of double-checking
        # that we reassemble the descriptor correctly when we retrieve it
        # from the RuntimeConfig service, in which we encode name and
        # code_version in the variable names as opposed to as separate
        # distinct variables.
        if descriptor['component_type'] != cls.type:
            raise exceptions.UnknownComponentException(
                    'Wrong component type `{}` for component `{}` (expected {})'.format(
                        descriptor['component_type'],
                        descriptor['name'],
                        cls.type))

        if 'name' not in descriptor:
            raise exceptions.InvalidComponentException(
                    "Variables `name` and `code_version` must be present in " \
                            "component descriptor (found: {})".format(
                                descriptor))

        if 'deployment_type' in descriptor and descriptor['deployment_type'] \
                not in cls.allowed_deployment_types:
                    raise exceptions.InvalidComponentException(
                            ('Deployment type {} not permitted for component '
                                '{}: (allowed types are {})').format(
                                descriptor['deployment_type'],
                                cls.type,
                                cls.allowed_deployment_types))

        if 'deployment_type' not in descriptor:
            # If no deployment type was specified, but if only one deployment
            # type is allowed for this component, then we can auto-select that
            # one deployment type.  But we should log it so that it's clear we
            # have done this.
            if len(cls.allowed_deployment_types) > 1:
                raise exceptions.InvalidComponentException(
                        ('Deployment type must be specified for component '
                            '{}: (allowed types are {})').format(
                            descriptor['name'],
                            cls.allowed_deployment_types))

            assert len(cls.allowed_deployment_types) == 1, \
                    'An internal has caused us to allow a component to be ' \
                    'defined with no allowed deployment types: {}!'.format(
                            cls)

            # Unpack the one deployment type from the set and augment the
            # descriptor with it
            descriptor = descriptor.copy()
            descriptor['deployment_type'] = list(cls.allowed_deployment_types)[0]

        return descriptor

    def _validate_config(self, config, decrypt_secrets):
        if not self.schema:
            if not config:
                return

            raise exceptions.InvalidComponentException(
                    'Component {} does not define a config schema, but '
                        'configuration {} was found!'.format(
                            self.type,
                            config))

        deserialize_context = self.descriptor.copy()
        deserialize_context['decrypt_secrets'] = decrypt_secrets
        loaded = self.schema(
                context=deserialize_context,
                exclude=self.ignore_fields).load(config or {})
        if loaded.errors:
            if config is None:
                raise exceptions.InvalidComponentException(
                    'No config file found at path `{}`, but some component settings are required: {}'.format(
                        self.descriptor['path'],
                        loaded.errors))

            raise exceptions.InvalidComponentException(loaded.errors)

        return loaded.data

    def __eq__(self, that):
        if not isinstance(that, self.__class__):
            return False

        return self.descriptor == that.descriptor and \
                self.config_dir == that.config_dir and \
                self.config == that.config

    def _asdict(self):
        return {
                'descriptor': self.descriptor,
                'config_dir': self.config_dir,
                'config': self.config,
                }


    def __repr__(self):
        return '{}/{}'.format(self.type, self.name)


class BaseCodeDeployComponent(BaseComponent):
    DEV_GCR_PROJECT_ID        = 'etsy-hadoop-sandbox-dev'
    PRODUCTION_GCR_PROJECT_ID = 'etsy-batchjobs-prod'

    code_repo_owner = 'Engineering'
    code_repo = 'BigData'
    git_tag_version_separator = '@'

    @property
    def git_tag_name(self):
        return self.type

    before_deploy_hooks = []
    after_deploy_hooks = []

    has_code_version = True

    _artifact_name = None
    @classmethod
    def get_artifact_name(cls):
        return cls._artifact_name or cls.type

    # Derived classes may set the deploy_files variable to define a set of files
    # or directories that exist within their service directories, and that can
    # only be pushed via a complete re-deploy of the service.
    deploy_files = []

    def get_deploy_files(self):
        """ Return the set of files for this component that can only be updated
            by re-deploying the component.
            This includes any files added via subclasses that override the
            deploy_files property, as well as any common files that should
            always trigger re-deploys (but may not always be present for any
            given component)
        """
        # Define some non-overrideable file names that will always trigger a
        # re-deploy if they change.  These files should be *optional*, so
        # we filter
        common_deploy_files = [
                'client_secret.json.enc',
                'star_etsycloud_com.chained.crt.enc',
                'star_etsycloud_com.key.enc',
                'service_account.json.enc',
                ]

        all_deploy_files = common_deploy_files + self.deploy_files

        return [
                filename for filename in all_deploy_files if
                os.path.isfile(os.path.join(self.config_dir, filename))
                ]

    def __init__(
            self,
            descriptor,
            config_dir,
            config,
            validate_config=True,
            decrypt_secrets=False,
            ignore_fields=None):

        super(BaseCodeDeployComponent, self).__init__(
                descriptor,
                config_dir,
                config,
                validate_config,
                decrypt_secrets,
                ignore_fields
                )

        from stallion.deploy.base import BaseDeployHook

        self._check_hooks(
                self.before_deploy_hooks,
                'before_deploy_hooks',
                BaseDeployHook)

        self._check_hooks(
                self.after_deploy_hooks,
                'after_deploy_hooks',
                BaseDeployHook)

    @property
    def code_version(self):
        return self.descriptor['code_version']

    @property
    def code_version_is_latest(self):
        return self.code_version == constants.LATEST

    def with_code_version(self, new_version):
        if not util.is_semver(new_version) and \
                new_version != constants.LATEST:
            raise Exception('Invalid version `{}`: not a semver!'.format(
                new_version))
        new_descriptor = self.descriptor.copy()
        new_descriptor['code_version'] = new_version

        return self.__class__(
                descriptor = new_descriptor,
                config_dir = self.config_dir,
                config = self.config)

    def build_image_url(self):
        if not frozenset([ 'gce', 'gae-flex', 'cloud-run' ]) & self.allowed_deployment_types:
            raise Exception(('Cannot build GCR image URL for component {}:{} '
                '(this component does not build containers!)').format(
                    self.type,
                    self.code_version))

        return 'gcr.io/{project_id}/{artifact_name}:{version}'.format(
                project_id = self.get_gcr_project_id(),
                artifact_name = self.get_artifact_name(),
                version = self.code_version)

    def get_gcr_project_id(self):
        if semver.parse_version_info(self.code_version).prerelease:
            return self.DEV_GCR_PROJECT_ID
        else:
            return self.PRODUCTION_GCR_PROJECT_ID


    def build_tarball_path(self):
        if not frozenset([ 'gae-standard', 'gae-base-app' ]) & self.allowed_deployment_types:
            raise Exception(('Cannot build tarball path for component {}:{} '
                '(this component does not deploy tarballs!)').format(
                    self.type,
                    self.code_version))

        return 'deploys/{artifact_name}/{artifact_name}-{version}.tar.gz'.format(
                artifact_name = self.get_artifact_name(),
                version = self.code_version)

    def latest_git_tag_version(self):
        from stallion.deploy import git
        return git.get_latest_version(
                self.code_repo_owner,
                self.code_repo,
                self.git_tag_name,
                self.git_tag_version_separator)

    def validate_git_tag_version(self, code_version):
        # TODO: this should attempt to retrieve the version tag directly,
        # rather than listing all versions
        from stallion.deploy import git
        available_versions = git.get_versions(
                self.code_repo_owner,
                self.code_repo,
                self.git_tag_version_separator,
                tag_names = set([ self.git_tag_name ]))

        if self.git_tag_name not in available_versions:
            raise exceptions.MissingVersionException('No git-tags available for component `{}` (searched for tag format `{}@<version>`)!'.format(
                self.type,
                self.git_tag_name))

        if code_version not in available_versions[self.git_tag_name]:
            raise exceptions.MissingVersionException('No git-tags available for {}:{} (available versions: {})'.format(
                self.git_tag_name,
                code_version,
                available_versions))

    def resolve_code_version_with_github(self):
        if self.code_version_is_latest:
            latest_version = self.latest_git_tag_version()
            logging.debug('Resolved code version for `%s:%s` to %s',
                    self.type,
                    self.code_version,
                    latest_version)
            return self.with_code_version(latest_version)

        self.validate_git_tag_version(self.code_version)

        return self


    def get_deploy_fingerprint(self, deployer):
        """ Fingerprint the subset of the configuration for this service that
            cannot be pushed via a config push, but rather that requires a
            full deploy.  Like the config fingerprint, this is just a md5, but
            of:
              - the service descriptor (ie the entry in the project-level
                settings.yaml file corresponding to this component)
              - the raw file contents of all files/directories within this
                component's config dir that are marked as deploy_files by
                either the component or its corresponding deployer.

            This should be used by CI/CD to help determine whether a service
            needs to be re-deployed, even when the deployed code version is
            correct
        """
        if not os.path.isdir(self.config_dir):
            logging.warning('Configuration directory not found at path %s: '
                'If this deployment depends on any configuration files, '
                'stallion will not be able to track changes to those files!',
                self.config_dir)

        digest = hashlib.md5()
        config_str = json.dumps(self.descriptor, sort_keys = True)
        digest.update(config_str.encode('utf-8'))

        all_deploy_files = sorted(deployer.deploy_files + self.get_deploy_files())
        if all_deploy_files:
            logging.debug(
                    'Computing digests for component %s, deployment files [%s]',
                    self.name,
                    ', '.join(all_deploy_files))
        else:
            logging.debug('No deploy_files found for component %s', self.name)

        for item in all_deploy_files:
            path = os.path.join(self.config_dir, item)

            (_, digest) = util.fingerprint(path, digest=digest)

        return digest.hexdigest()

    def needs_redeploy(self, deployer, conf_manager):
        deploy_fingerprint = self.get_deploy_fingerprint(deployer)

        existing_deploy_fingerprint = conf_manager.get_fingerprints()

        result = deploy_fingerprint != \
                existing_deploy_fingerprint.get(self.name, {}).get('deploy')

        if result:
            logging.debug(
                    'Component %s requires re-deploy due to fingerprint change (%s => %s)',
                    self.name,
                    existing_deploy_fingerprint,
                    deploy_fingerprint)

        return result

    @classmethod
    def _validate_descriptor(cls, descriptor):
        # Extend base validator to make sure that code_version is present
        super(BaseCodeDeployComponent, cls)._validate_descriptor(descriptor)

        if 'code_version' not in descriptor:
            raise exceptions.InvalidComponentException(
                    "Variable `code_version` must be present in " \
                            "descriptor for component {} (found: {})".format(
                                descriptor['name'],
                                descriptor))

        return descriptor

    def __repr__(self):
        return '{}/{}:{}'.format(self.type, self.name, self.code_version)

