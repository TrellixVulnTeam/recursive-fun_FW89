from builtins import map
import hashlib
import os
import logging
from collections import Counter
import six
import semver


def is_semver(item):
    """ Determine whether the provided argument is a valid semver string.
        To be valid the argument must meet these conditions:

        1) Be considered valid by the semver library
        2) Not contain a '.' in the prerelease identifier (if it exists).  GCP doesn't play nicely with '.' as a rule

        :param item: the argument to check
        :type item: string
        :returns: boolean indicating whether the argument was a semver
    """
    try:
        semver.VersionInfo.parse(item)
        prerelease = semver.VersionInfo.parse(item).prerelease
        return prerelease is None or '.' not in prerelease
    except:
        return False


def encode_version(version):
    """ Encode a semver by replacing `.` with `-` and forcing to lowercase, to make GCP deployers
        happy (`.` is not a valid character for many/(most?/all?) GCP
        platforms

        :param version: the semver, which is valid according to is_semver
        :type version: str
        :returns: a string containing the encoded semver
        :raises ValueError: if the input version is not a valid semver
    """
    if not is_semver(version):
        raise ValueError('Invalid version `{}`: not a semver!'.format(version))

    return version.replace('.', '-', 2).lower()


def decode_version(enc_version):
    """ Decode an encoded semver by replacing the first two instances of `-` with `.`.  See encode_version,
        above.
        :param enc_version: the encoded semver
        :type enc_version: str
        :returns: a string containing the decoded semver
    """
    version = enc_version.replace('-', '.', 2)

    if not is_semver(version):
        logging.warn('Decoded an invalid encoded semver `%s`', enc_version)

    return version


def ensure_no_dupes(items, keyer, error_context, exception_cls = Exception):
    key_counts = Counter(list(map(keyer, items)))
    dupe_keys = [ key for (key, count) in six.iteritems(key_counts) if count > 1 ]

    if dupe_keys:
        raise exception_cls(
                'Duplicate keys `{}` found in context {}'.format(
                    dupe_keys,
                    error_context,
                    ))

def keyby(items, keyer, error_context):
    """ Make a dictionary out of the list of items provided, using the
        supplied key function
    """

    ensure_no_dupes(items, keyer, error_context)

    return { keyer(item): item for item in items }

def get_leaf_dirs(base_dir):
    # Get a list of all leaf dirs in a directory hierarchy.  Could be used to
    # generate a list of all directories at all, too, I guess.
    # Equivalent to something like `find base_dir -type d` but then deduped
    # to include only the leafs.
    results = []
    def get_subdirs(current):
        contents = ( os.path.join(current, d) for d in os.listdir(current) )
        return [ d for d in contents if os.path.isdir(d) ]

    def _doit(current):
       subdirs = get_subdirs(current)
       if not subdirs:
           results.append(current)
           return

       for subdir in subdirs:
           _doit(subdir)

    if not os.path.isdir(base_dir):
        raise Exception('Not a directory: {}'.format(base_dir))

    _doit(base_dir)

    return results

def get_all_files(directory):
    for (parent_dir, subdirs, files) in os.walk(directory):
        for f in files:
            yield os.path.join(parent_dir, f)

def fingerprint(file_or_directory, digest = None):
    # Compute a "fingerprint" for a file or directory on the filesystem; used by Jenk
    # to determine whether files have changed and need to be re-deployed.
    # Take an optional `digest` argument in case the external caller wants
    # to include even more stuff in the digest
    if not os.path.exists(file_or_directory):
        raise Exception('Cannot fingerprint item `{}`: does not exist!'.format(file_or_directory))

    all_files = base_dir = None
    if os.path.isfile(file_or_directory):
        all_files = [file_or_directory]
        base_dir = os.path.dirname(os.path.abspath(file_or_directory))
    else:
        all_files = sorted(get_all_files(file_or_directory))
        base_dir = file_or_directory

    digest = digest or hashlib.md5()
    for f in all_files:
        # include the relative filename in the hash, so that we can detect
        # filename changes that do not induce lexical order changes
        digest.update(os.path.relpath(f, start=base_dir).encode('utf-8'))
        with open(f, 'rb') as _in:
            digest.update(_in.read())

    return (digest.hexdigest(), digest)

def gcs_download(bucket_name, path, local_dir):
    from google.cloud import storage

    client = storage.Client()
    bucket = client.bucket(bucket_name)

    blob = bucket.blob(path)

    if not blob.exists():
        raise Exception('GCS path does not exist: gs://{}/{}'.format(
            bucket, path))

    local_filename = os.path.join(local_dir, os.path.basename(path))

    logging.info("Downloading object gs://%s%s to %s",
            bucket_name,
            path,
            local_filename)

    blob.download_to_filename(local_filename)

    return local_filename


def dict_subtree(item, subtree):
    """ Extract a subtree out of a nested dictionary.  For example, for the
        dictionary:
            {
                'foo': 10,
                'bar': {
                    'baz': 20
                }
            },
       if we call dict_subtree(item, ['bar', 'baz']), the result will be 20.

       :param item: the dictionary
       :type item: dict
       :param subtree: the subtree
       :type subtree: list<str>
    """
    def _inner(sub_item, remaining_subtree):
        if not remaining_subtree:
            return sub_item

        if not isinstance(sub_item, dict):
            raise ValueError(
                '''Invalid request: subtree {} is not valid in {}:
                   Path contains non-leaf node {} at position {} that is not a dict!
                '''.format(subtree, item, sub_item, subtree[:-len(remaining_subtree)]))

        if remaining_subtree[0] not in sub_item:
            raise KeyError('Invalid request: subtree {} not present in {}'.format(
                subtree,
                item))

        return _inner(sub_item[remaining_subtree[0]], remaining_subtree[1:])
    return _inner(item, subtree)
